<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/wall-e-icon%20(1).png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/wall-e-icon%20(1).png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Stay Hungry, Stay Foolish.">
<meta property="og:type" content="website">
<meta property="og:title" content="Vincentの银河系漫游指南">
<meta property="og:url" content="https://vincentcheungkokomo.github.io/index.html">
<meta property="og:site_name" content="Vincentの银河系漫游指南">
<meta property="og:description" content="Stay Hungry, Stay Foolish.">
<meta property="article:author" content="Vincent Zhang">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","offset":6,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://vincentcheungkokomo.github.io/"/>





  <title>Vincentの银河系漫游指南</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-164518868-1', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vincentの银河系漫游指南</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentcheungkokomo.github.io/2021/05/15/vim%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cosmos_dna.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincentの银河系漫游指南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/15/vim%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" itemprop="url">vim入门教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-15T11:20:34+08:00">
                2021-05-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/05/15/vim%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/05/15/vim%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考视频教程 <a href="https://www.bilibili.com/video/BV1Yt411X7mu?from=search&amp;seid=7973128649013153114" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yt411X7mu?from=search&amp;seid=7973128649013153114</a><br>command 命令模式</p>
<p>edit 编辑模式 按i 进入编辑模式</p>
<p>按esc退回命令模式<br>:wq保存退出  :wq filename 例如(:wq code.c)<br>:q!不保存退出</p>
<p>cat code.c 查看代码</p>
<p>修改 vim code.c</p>
<p>命令模式下<br>    一次生效<br>    语法高亮 :syntax on/enable<br>    显示行号 :set number</p>
<p>永久生效 vim配置文件 <del>/.表示当前用户的根目录<br>vim ~/.vimrc<br>借用他人的vim配置文件<br><a href="https://github.com/amix/vimrc/blob/master/vimrcs/basic.vim" target="_blank" rel="noopener">https://github.com/amix/vimrc/blob/master/vimrcs/basic.vim</a><br>raw copy到</del>/.vimrc</p>
<p>命令模式下的方向键<br>H⬅️<br>J⬇️   10J 往下跳10行<br>K⬆️   10k 往上跳10行<br>L➡️<br>w （word） 跳到下一个单词<br>b （back） 往回跳一个单词</p>
<p>page up 上翻页<br>page down 下翻页</p>
<p>ctrl + f （forward） = page down<br>ctrl + b （backward） = page up</p>
<p>gg跳到指定行 88gg 跳到第88行</p>
<p>esc取消错误命令</p>
<p>查找指定单词 /word<br>查找node  /node  n下一个 shift+n 上一个</p>
<p>剪切整行 cc  会进入编辑模式 esc返回命令模式<br>c2c剪切两行<br>恢复整行 u (undo)</p>
<p>粘贴p （paste）</p>
<p>v 进入visual  光标选择多行<br>yy复制当前行</p>
<p>代码自动补全 ctrl + n 只能补全出现过的单词</p>
<p>第三方插件管理系统 vim plug</p>
<p>curl -fLo ~/.vim/autoload/plug.vim –create-dirs <br>    <a href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim" target="_blank" rel="noopener">https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</a></p>
<p>如何解决类似 curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused 的问题 #10<br><a href="https://github.com/hawtim/blog/issues/10" target="_blank" rel="noopener">https://github.com/hawtim/blog/issues/10</a></p>
<p>vim awesome</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentcheungkokomo.github.io/2021/05/11/shell%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cosmos_dna.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincentの银河系漫游指南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/11/shell%E6%95%99%E7%A8%8B/" itemprop="url">shell教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-11T21:39:57+08:00">
                2021-05-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/05/11/shell%E6%95%99%E7%A8%8B/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/05/11/shell%E6%95%99%E7%A8%8B/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentcheungkokomo.github.io/2021/04/21/vscode%E9%85%8D%E7%BD%AEtf-gpu%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cosmos_dna.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincentの银河系漫游指南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/21/vscode%E9%85%8D%E7%BD%AEtf-gpu%E7%8E%AF%E5%A2%83/" itemprop="url">vscode配置tf-gpu环境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-21T13:25:11+08:00">
                2021-04-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/04/21/vscode%E9%85%8D%E7%BD%AEtf-gpu%E7%8E%AF%E5%A2%83/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/04/21/vscode%E9%85%8D%E7%BD%AEtf-gpu%E7%8E%AF%E5%A2%83/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentcheungkokomo.github.io/2021/03/29/TF%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cosmos_dna.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincentの银河系漫游指南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/29/TF%E6%95%99%E7%A8%8B/" itemprop="url">TF教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-29T17:24:10+08:00">
                2021-03-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/03/29/TF%E6%95%99%E7%A8%8B/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/03/29/TF%E6%95%99%E7%A8%8B/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentcheungkokomo.github.io/2021/03/20/tvm%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cosmos_dna.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincentの银河系漫游指南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/20/tvm%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/" itemprop="url">tvm安装编译</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-20T22:32:37+08:00">
                2021-03-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/03/20/tvm%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/03/20/tvm%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>官网教程<br><a href="https://tvm.apache.org/docs/install/from_source.html" target="_blank" rel="noopener">https://tvm.apache.org/docs/install/from_source.html</a><br>克隆repo， 注意子模块不完整的问题<br>git clone –recursive <a href="https://github.com/apache/tvm" target="_blank" rel="noopener">https://github.com/apache/tvm</a> tvm<br>新建build目录<br>mkdir build<br>cp cmake/config.cmake build<br>编辑 build目录下的cmake文件<br>macos <code>set(LDFLAGS -lc++abi)</code><br><code>set(USE_GRAPH_RUNTIME ON)</code></p>
<p>llvm生成cpu代码<br><code>set(USE_LLVM /path/to/your/llvm/bin/llvm-config)</code><br><code>set(USE_LLVM ON</code></p>
<p>linux安装编译tvm<br><a href="https://sunicyosen.github.io/2019/08/02/TVM-Study-1-Setup-Environment" target="_blank" rel="noopener">https://sunicyosen.github.io/2019/08/02/TVM-Study-1-Setup-Environment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentcheungkokomo.github.io/2021/03/20/llvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cosmos_dna.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincentの银河系漫游指南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/20/llvm/" itemprop="url">llvm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-20T16:47:05+08:00">
                2021-03-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/03/20/llvm/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/03/20/llvm/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>macos安装llvm<br><a href="https://blog.csdn.net/Charliewolf/article/details/101145768" target="_blank" rel="noopener">https://blog.csdn.net/Charliewolf/article/details/101145768</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentcheungkokomo.github.io/2021/02/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cosmos_dna.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincentの银河系漫游指南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" itemprop="url">Linux常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-26T16:24:27+08:00">
                2021-02-26
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/02/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/02/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>date 显示服务器时间<br>cal 显示日历</p>
<p>文件系统<br>root /根目录<br>cd / 跳到根目录<br>ls 查看当前文件<br>ls -l 查看当前文件详细信息<br>    第一个字母d 表示目录<br>    第一个字母- 表示文件</p>
<hr>
<p>clear 清除当前窗口<br>cd .. 退回到上层文件夹<br>mkdir tutorial 新建文件夹<br>rmdir tutorial 删除文件夹<br>cp file1.txt file2.txt 拷贝file1.txt到file2.txt</p>
<hr>
<p>cat filename 查看文件内容<br>diff file1 file2 比较文件差异<br>head（file2.txt -n 1） 查看文件的前几行<br>tail（file2.txt -n 1） 查看文件的后几行</p>
<hr>
<p>word count<br>wc file2.txt 结果 行数 单词数 多少字节<br>wc -l file2.txt 只查看行数<br>wc -w file2.txt 只查看单词数<br>wc -c file2.txt 只查看字节数</p>
<h2 id="rm-filename-删除文件-不可撤销"><a href="#rm-filename-删除文件-不可撤销" class="headerlink" title="rm filename 删除文件 不可撤销"></a>rm filename 删除文件 不可撤销</h2><p>mv<br>修改文件名<br>    mv file1.txt helloworld.txt<br>移动文件<br>    mv helloworld.txt CTutorial/</p>
<p>less filename.txt 只显示文档file的一部分 然后用上下箭头来翻动<br>使用q来退出</p>
<hr>
<p>chmod命令 更改权限<br>三段<br>u作者 g小组 o其他<br>rwx   rwx    rwx<br>110<br>二进制表示也行<br>读/写/运行</p>
<p>chmod u-r file2.txt 作者权限减r(不可读<br>chmod u+r file2.txt 恢复可读权限<br>chmod go-r file2.txt 除作者外其他人都不能读<br>chmod 444 全部可读</p>
<hr>
<p>grep命令 用于对文本文件进行搜索<br>grep France paris.txt 在paris.txt是否有France<br>grep a paris.txt  所有包含字母a的单词 正则表达式<br>grep a* paris.txt  字母a出现任意次的单词<br>grep aa* paris.txt  字母a至少出现一次的单词</p>
<p>grep ^F paris.txt 以F开头<br>grep d.g paris.txt  .通配符<br>grep d[oi]g paris.txt  [o或者i]<br>grep d[A-Za-z]g paris.txt [A-Za-z]任意英文字母</p>
<p>命令组合<br>查找并计数<br>grep d[A-Za-z]g paris.txt | wc</p>
<hr>
<p>zip 文件压缩<br>zip CProgram.zip * 压缩当前文件夹的内容到CProgram<br>unzip解压</p>
<p>tar<br>压缩<br>tar -zcvf CTut.tar.gz Ctutorial/<br>解压<br>tar -zxvf CTut.tar.gz</p>
<hr>
<p>下载<br>wget URL -O filename</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentcheungkokomo.github.io/2021/02/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cosmos_dna.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincentの银河系漫游指南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url">操作系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-25T20:32:35+08:00">
                2021-02-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/02/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/02/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentcheungkokomo.github.io/2020/12/19/VS-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cosmos_dna.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincentの银河系漫游指南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/19/VS-code/" itemprop="url">VS code</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-19T22:42:08+08:00">
                2020-12-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/12/19/VS-code/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/12/19/VS-code/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++环境</p>
<p>python环境</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentcheungkokomo.github.io/2020/12/18/labuladong-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cosmos_dna.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincentの银河系漫游指南">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/18/labuladong-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url">labuladong_数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-18T15:57:01+08:00">
                2020-12-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/12/18/labuladong-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/12/18/labuladong-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表节点的结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h2><h3 id="1-递归反转整个链表"><a href="#1-递归反转整个链表" class="headerlink" title="1. 递归反转整个链表"></a>1. 递归反转整个链表</h3><p>明确递归函数的定义： 输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverse(ListNode head) &#123;</span><br><span class="line">    if (head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode last &#x3D; reverse(head.next);</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line">    head.next &#x3D; null;</span><br><span class="line">    return last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-反转链表前N个节点"><a href="#2-反转链表前N个节点" class="headerlink" title="2.  反转链表前N个节点"></a>2.  反转链表前N个节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将链表的前 n 个节点反转（n &lt;&#x3D; 链表长度）</span><br><span class="line">ListNode successor &#x3D; null; &#x2F;&#x2F; 后继节点</span><br><span class="line">&#x2F;&#x2F; 反转以head为起点的n个节点， 返回新的头节点</span><br><span class="line">ListNode reverseN(ListNode head, int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 记录n+1个节点</span><br><span class="line">        successor &#x3D; head.next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 以head.next为起点， 需要反转前n-1个节点</span><br><span class="line">    ListNode last &#x3D; reverseN(head.next, n-1);</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line">    &#x2F;&#x2F; 让反转后的head节点和后面的节点连起来</span><br><span class="line">    head.next &#x3D; successor;</span><br><span class="line">    return last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-反转链表的一部分"><a href="#3-反转链表的一部分" class="headerlink" title="3. 反转链表的一部分"></a>3. 反转链表的一部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverseBetween(ListNode head, int m, int n) &#123;</span><br><span class="line">    &#x2F;&#x2F; base case</span><br><span class="line">    if (m &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 相当于反转前 n 个元素</span><br><span class="line">        return reverseN(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 前进到反转的起点触发 base case</span><br><span class="line">    head.next &#x3D; reverseBetween(head.next, m-1, n-1);</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>// 反转以 a 为头结点的链表<br>ListNode reverse(ListNode a) {<br>    ListNode pre, cur, nxt;<br>    pre = null; cur = a; nxt = a;<br>    while (cur != null) {<br>        nxt = cur.next;<br>        // 逐个节点反转<br>        cur.next = pre;<br>        // 更新指针位置<br>        pre = cur; // 最后的值为最后的节点<br>        cur = nxt; // 最后的值为NULL<br>    }<br>    // 返回反转后的头节点<br>    return pre;<br>}</p>
<p>/** 反转区间 [a, b) 的元素，注意是左闭右开 */<br>ListNode reverse(ListNode a, ListNode b) {<br>    ListNode pre, cur, nxt;<br>    pre = null; cur = a, nxt = a;<br>    while (cur != b) {<br>        nxt = cur.next;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = nxt;<br>    }<br>    return pre;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">### 25.k个一组反转链表</span><br></pre></td></tr></table></figure>
<p>ListNode reverseKGroup(ListNode head, int k) {<br>    if (head == null) return null;<br>    // 区间 [a, b) 包含 k 个待反转元素<br>    ListNode a, b;<br>    a = b = head;<br>    for (int i = 0 ; i &lt; k ; i++) {<br>        // 不足k个， 不需要反转， base case<br>        if (b == null)<br>            return head;<br>        b = b.next;<br>    }<br>    // 反转前k个元素<br>    ListNode newHead = reverse(a, b);<br>    // 递归反转后续链表并连接起来<br>    a.next = reverseKGroup(b, k);<br>    return newHead;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">### 判断回文字符串</span><br></pre></td></tr></table></figure>
<p>boolean isPalindrome(String s) {<br>    int left = 0, right = s.length - 1;<br>    while (left &lt; right) {<br>        if (s[left] != s[right])<br>            return false;<br>        left++;<br>        right–;<br>    }<br>    return true;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 234判断回文单链表</span><br><span class="line">单链表无法倒着遍历， 无法使用双指针技巧</span><br><span class="line">将原始链表反转后存入一条新的链表， 然后比较这两条链表是否相同</span><br></pre></td></tr></table></figure>
<p>boolean isPalindrome(ListNode head) {</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 二叉树的遍历方式</span><br></pre></td></tr></table></figure>
<p>void traverse(TreeNode root) {<br>    // 前序遍历代码<br>    traverse(root.left)<br>    // 中序遍历代码<br>    traverse(root.right)<br>    // 后序遍历代码<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">####链表的前序遍历和后序遍历</span><br></pre></td></tr></table></figure>
<p>void traverse(ListNode head) {<br>    // 前序遍历代码<br>    traverse(head.next);<br>    // 后序遍历代码<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;* 倒序打印单链表中的元素值 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>void traverse(ListNode head) {<br>    if (head == null) return;<br>    traverse(head.next);<br>    // 后序遍历代码<br>    print(head.val);<br>}</p>
<pre><code>
模仿双指针实现回文判断的功能：
ListNode left;

boolean isPalindrome(ListNode head) {
    left = head;
    return traverse(head);
}

boolean traverse(ListNode right) {
    if (right == null) return true;
    boolean res = traverse(right.next);
    // 后序遍历代码
    res = res &amp;&amp; (right.val == left.val);
    left = left.next;
    return res;
}


####优化空间复杂度
ListNode slow, fast;
slow = fast = head;
while (fast != null &amp;&amp; fast.next != null) {
    slow = slow.next;
    fast = fast.next.next;
}
// slow 指针现在指向链表中点
if (fast != null)
    slow = slow.next;

ListNode left = head;
ListNode right = reverse(slow);

while (right != null) {

}




二叉树遍历框架
/* 二叉树遍历框架 */
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}






快速排序
void quicksort(int[] nums, int lo, int hi) {
    /****** 前序遍历位置 ******/
    // 通过交换元素构建分界点 p
    int p = partition(nums, lo, hi);
    /*****************/
    quicksort(nums, lo, p-1);
    quicksort(nums, p+1, hi);
}

归并排序
void sort(int[] nums, int lo, int hi) {
    int mid = (lo + hi) / 2;
    sort(nums, lo, mid);
    sort(nums, mid, hi);

    /****** 后序遍历位置 ******/
    // 合并两个排好序的子数组
    merge(nums, lo, mid, hi);
}

只要涉及到递归，都可以抽象成二叉树的问题
写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。

计算一棵二叉树共有几个节点：
// 定义：count(root) 返回以 root 为根的树有多少节点
int count(TreeNode root) {
    // base case
    if (root == null) return 0;
    // 自己加上子树的节点数就是整棵树的节点数
    return 1 + count(root.left) + count(root.right);
}

# 226.翻转二叉树（简单）
我们发现只要把二叉树上的每一个节点的左右子节点进行交换，
最后的结果就是完全翻转之后的二叉树。

TreeNode invertTree(TreeNode root) {
    // base case
    if (root == null)
        return null;

    /*****前序遍历位置***********/ 
    // root 节点需要交换它的左右子节点
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;

    // 让左右子节点继续翻转它们的子节点
    invertTree(root.left);
    invertTree(root.right);

    return root;
}


# 116.填充每个节点的下一个右侧节点指针（中等）
// Node connect(Node root) {
//     if (root == null || root.left == null) {
//         return root;
//     }
//     root.left.next = root.right;  // 连接每个节点的左右子节点

//     connect(root.left);
//     connect(root.right);

//     return root;
// }


// 主函数
Node connect(Node root) {
    if (root == null) 
        return null;
    connectTwoNode(root.left, root.right);
    return root;
}

// 辅助函数
void connectTwoNode(Node node1. Node node2) {
    if (node1 == null || node2 == null) {
        return;
    }
    /***前序遍历位置 ******/
    // 将传入的两个节点连接
    node1.next = node2;

    // 连接相同父节点的两个子节点
    connectTwoNode(node1.left, node1.right);
    connectTwoNode(node2.left, node2.right);
    // 连接跨越父节点的两个子节点
    connectTwoNode(node1.right, node2.left);

}



# 114.二叉树展开为链表（中等）
// 定义：将以 root 为根的树拉平为链表
void flatten(TreeNode root) {
    // base case
    if (root == null) return;

    // 将 root 的左子树和右子树拉平。
    flatten(root.left);
    flatten(root.right);

    /******后序遍历位置******/
    // 1、左右子树已经被拉平成一条链表
    TreeNode left = root.left;
    TreeNode right = root.right;

    // 2、将左子树作为右子树
    root.left = null;
    root.right = left;

    // 3、将 root 的右子树接到左子树(当前右子树)下方，然后将整个左子树作为右子树。
    TreeNode p = root;
    while (p.right != null) {
        p = p.right;    
    }
    p.right = right; // 将 root 的右子树接到左子树
}


#654.最大二叉树（中等）
int[] nums = [3,2,1,6,0,5];
reeNode constructMaximumBinaryTree(int[] nums) {
    return build(nums, 0, nums.length-1);
}
// 构造二叉树
TreeNode build(int[] nums, int lo, int hi) {
    // base case
    if (lo &gt; hi) {
        return null;
    }

    // 找出数组中的最大值和对应的索引
    int maxVal = Integer.MIN_VALUE;
    int index = -1;
    for (int i=lo; i&lt;=hi; i++) {
        if(nums[i] &gt; maxVal) {
            maxVal = nums[i];
            index = i;
        }
    }
    // 构造根节点
    TreeNode root = new TreeNode(maxVal);
    // 递归调用构造左右子树
    root.left = build(nums, lo, index-1);
    root.right = build(nums, index+1, hi);

    return root;
}

#105.从前序与中序遍历序列构造二叉树（中等）
// 1. 从前序遍历结果中找到root
// 2. 根据root的值，在中序遍历结果找到root的索引index
// 3. 根据索引index, 把中序数组分为左右两部分left, right
// 4. 在左右两部分递归 1，2，3

/* 主函数 */
TreeNode buildTree(int[] preorder, int[] inorder) {
    return build(preorder, 0, preorder.length - 1,
                 inorder, 0, inorder.length - 1);
}

/* 
   若前序遍历数组为 preorder[preStart..preEnd]，
   后续遍历数组为 postorder[postStart..postEnd]，
   构造二叉树，返回该二叉树的根节点 
*/
TreeNode build(int[] preorder, int preStart, int preEnd, 
               int[] inorder, int inStart, int inEnd) {
    if (preStart &gt; preEnd) {
        return null;
    }

    // root 节点对应的值就是前序遍历数组的第一个元素
    int rootVal = preorder[preStart];
    // rootVal 在中序遍历数组中的索引
    int index = 0;
    for (int i = inStart; i &lt;= inEnd; i++) {
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }
    int leftSize = index - instart;
    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右子树
    root.left = build(preorder, preStart+1, preStart+leftsize,
                      inorder, instart, index-1);

    root.right = build(preorder, preStart+leftSize+1, preEnd,
                       inorder, index+1, inEnd);
    return root;
}



#106.从中序与后序遍历序列构造二叉树（中等）
TreeNode buildTree(int[] inorder, int[] postorder) {
    return build(inorder, 0, inorder.length - 1,
         postorder, 0, postorder.lenght - 1);
}

TreeNode build(int[] inorder, int inStart, int inEnd,
     int[] postorder, int postStart, int postEnd) {
    // root 节点对应的值就是后序遍历数组的最后一个元素
    int rootVal = postorder[postEnd];
    // rootVal 在中序遍历数组中的索引
    int index = 0;
    for (int i = inStart; i &lt;= inEnd; i++) {
         if (inorder[i] == rootVal) {
             index = i;
             break;
         }
    } 

    TreeNode root = new TreeNode(rootVal);
    int leftSize = index - inStart; // 左半部分的大小
    // 递归构造左右子树
    root.left = build(inorder, inStart, index-1,
                     postorder, postStart, postStart+leftsize-1);

    root.right = build(inorder, index+1, inEnd,
        postorder, postStart+leftSize, postEnd-1);

    return root;
}

做二叉树的问题，关键是把题目的要求细化，搞清楚根节点应该做什么，
然后剩下的事情抛给前/中/后序的遍历框架就行了。


#652.寻找重复的子树（中等）
重复子树：具有相同的结构以及相同的节点值
// 记录所有子树 
HashSet&lt;String&gt; memo = new HashSet&lt;&gt;();
// 记录重复的子树根节点  使用Hashset的话 res的结果会重复 
LinkedList&lt;TreeNode&gt; res = new LinkedList&lt;&gt;();
// 通过拼接字符串的方式把二叉树序列化
String traverse(TreeNode root) {
    // 对于空节点，可以用一个特殊字符表示
    if (root == null) {
        return &apos;#&apos;;
    }
    // 将左右子树序列化成字符串
    String left = traverse(root.left);
    String right = traverse(root.right);
    /* 后序遍历代码位置 */
    // 左右子树加上自己，就是以自己为根的二叉树序列化结果
    String subTree = left + &quot;,&quot;+ root.val + &quot;,&quot; + right;

    if (memo.contains(subTree)) {
        res.add(root); 
    } else {
        memo.add(subTree); 
    }
    return subTree;
}

List&lt;TreeNode&gt; findDuplicateSubtrees(TreeNode root) {
    traverse(root);
    // 当前节点该做什么？
    // 当前节点子树的结构 // 树序列化
    // 与其他节点子树进行比较
    return res;
}


// 记录所有子树以及出现的次数
HashMap&lt;String, Integer&gt; memo = new HashMap&lt;&gt;();
// 记录重复的子树根节点
LinkedList&lt;TreeNode&gt; res = new  LinkedList&lt;&gt;();

/* 主函数 */
List&lt;TreeNode&gt; findDuplicatedSubtrees(TreeNode root) {
    traverse(root);
    return res;
}

/* 辅助函数 */
String traverse(TreeNode root) {
    // 对于空节点，可以用一个特殊字符表示
    if (root == null) {
        return &apos;#&apos;;
    }
    // 将左右子树序列化成字符串
    String left = traverse(root.left);
    String right = traverse(root.right);
    /* 后序遍历代码位置 */
    // 左右子树加上自己，就是以自己为根的二叉树序列化结果
    String subTree = left + &quot;,&quot;+ root.val + &quot;,&quot; + right;

    int freq = memo.getOrDefault(subTree, 0);
    // 多次重复也只会被加入结果集一次
    if (freq == 1) {
        res.add(root);
    }
    // 给子树对应的出现次数加1
    memo.put(subTree, freq + 1);
    return subTree;
}

二叉搜索树 BST
AVL树 红黑树 B+树 线段树

中序遍历是有序的
void traverse(TreeNode root) {
    if (root == null) return;

    traverse(root.left);
    // 中序遍历位置
    print(root.val);
    traverse(root.right);
}

#230 二叉搜索树中第k小的元素

int kthSmallest(TreeNode root, int k) {
    // 利用BST的中序遍历特性
    inorder(root, k);
    return res;
}

// 记录结果
int res = 0;
// 记录当前元素的排名
int rank = 0;
void inorder(TreeNode root, int k) {
    if (root == null) {
        return;
    }
    inorder(root.left, k);
    /* 中序遍历代码位置 */
    rank++;  // 真正访问根节点的时候 rank+1
    if (k == rank) {
        // 找到第k小的元素
        res = root.val;
        return;
    }
    inorder(root.right, k);
}

已知节点数的二叉搜索树节点 
class TreeNode {
    int  val;
    int size; // 以该节点为根的树节点总数
    TreeNode left;
    TreeNode right;
}


#538 二叉搜索树转换为累加树
降序打印节点的值
void postorder(TreeNode root) {
    if (root == null) return;
    // 先递归遍历右子树
    postorder(root.right);
    print(root.val);
    // 后递归遍历左子树
    postorder(root.left);
}

TreeNode convert(TreeNode root) {
    postorder(root);
    return root;
}

int sum = 0; // 记录累加和

void postorder(TreeNode root) {
    if (root == null) return;

    postorder(root.right);
    sum += root.val;
    // 将BST转化成累加树
    root.val = sum; 
    postorder(root.left);
}


BST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，
要么利用中序遍历的特性满足题目的要求，也就这么些事儿吧。

#98.验证二叉搜索树（中等）
boolean isValidBST(TreeNode root) {
    return isValidBST(root, null, null);
}

/* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val */
boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
    // base case
    if (root == null) return true;
    // 若root.val不符合min max的限制，说明不是合法BST
    if (min != null &amp;&amp; root.val &lt;= min.val) return false;
    if (max != null &amp;&amp; root.val &gt;= max.val) return false; 
    // 限定左子树的最大值是root.val, 右子树的最小值是root.val
    return isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);
}


#700.二叉搜索树中的搜索（简单）
boolean isInBST(TreeNode root, int target) {
    if (root == null) return false;

    if (target == root.val) 
        return true;
    else if (target &lt; root.val) {
        return isInBST(root.left, target);
    } else {
        return isInBST(root.right, target);
    }
}

// BST 的遍历框架
void BST(TreeNode root, int target) {
    if (target == root.val) 
        // do something
    else if (target &lt; root.val) {
        BST(root.left, target);
    } else {
        BST(root.right, target);
    }
}


#701.二叉搜索树中的插入操作（中等）
遍历（找） + 访问（改）
找插入位置 插入
TreeNode insertIntoBST(TreeNode root, int val) {
    // 找到空位置插入新节点
    if (root == null) return new TreeNode(val);

    if (val &lt; root.val) {
        root.left = insertIntoBST(root.left, int val);
    } else if (val &gt; root.val) {
        root.right = insertIntoBST(roor.right, int val);
    } else {
        // pass
    }
    return root;
}


#450.删除二叉搜索树中的节点（中等）
先找再改
TreeNode deleteNode(TreeNode root, int key) {
    if (root.val == key) {
        // 找到了， 进行删除
        if (root.left == null &amp;&amp; root.right == null) 
            return null;
        else if (root.left == null)
            return root.right;
        else if (root.right == null)
            return root.left;
        else {
            // 找到左子树最大的节点，或右子树最小的节点
            TreeNode minNode = getMin(root.right);
            // 把root 改成 minNode
            root.val = minNode.val;
            // 转而去右子树删除 minNode
            root.right = deleteNode(root.right, minNode.val);
        }
    } else if (key &lt; root.val) {
        // 去左子树找
        root.left = deleteNode(root.left, key);
    } else {
        root.right = deleteNode(root.right, key);
    }
    return root;
}


TreeNode getMin(TreeNode node) {
    // BST 最左边的就是最小的
    while (node.left != null) node = node.left;
    return node;
}



#297.二叉树的序列化和反序列化（困难）

public class Codec {

    // 把一棵二叉树序列化成字符串
    public String serialize(TreeNode root) {}

    // 把字符串反序列化成二叉树
    public TreeNode deserialize(String data) {}
}

# 序列化
// 代表分隔符的字符
String SEP = &quot;,&quot;;
// 代表null空指针的字符
String NULL = &quot;#&quot;;

/* 主函数，将二叉树序列化为字符串 */
String serialize(TreeNode root) {
    // 用于拼接字符串
    StringBuilder sb = new StringBuilder();        
    serialize(root, sb);
    return sb.toString();
}

# 前序
/* 辅助函数，将二叉树存入 StringBuilder */
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    /****** 前序遍历位置 ******/
    sb.append(root.val).append(SEP);
    /***********************/

    serialize(root.left, sb);
    serialize(root.right, sb);
}

# 后序
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    serialize(root.left, sb);
    serialize(root.right, sb);

    /****** 后序遍历位置 ******/
    sb.append(root.val).append(SEP);
    /***********************/
}


字符串转列表
String data = &quot;1,2,#,4,#,#,3,#,#,&quot;;
String[] nodes = data.split(&quot;,&quot;);
nodes: 1 -&gt; 2 -&gt; # -&gt; 4 -&gt; # -&gt; # -&gt; 3 -&gt; # -&gt; # 


# 反序列化
/* 主函数，将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    // 将字符串转换成列表
    LinkedList&lt;String&gt; nodes = new LinkedList&lt;&gt;();
    for (String s : data.split(SEP)) {
        nodes.addLast(s);
    }
    return deserialize(nodes);
}

# 前序
/* 辅助函数，通过 nodes 列表构造二叉树 */
TreeNode deserialize(LinkedList&lt;String&gt; nodes) {
    if (nodes.isEmpty()) 
        return null;

    /****** 前序遍历位置 ******/
    // 列表最左侧就是根节点
    String first = nodes.removeFirst();
    if (first.equals(NULL)) 
        return null;
    // 字符串解析为整型
    TreeNode root = new TreeNode(Integer.parseInt(first));

    root.left = deserialize(nodes);
    root.right = deserialize(nodes);

    return root;
}

# 后序
/* 辅助函数，通过 nodes 列表构造二叉树 */
TreeNode deserialize(LinkedList&lt;String&gt; nodes) {
    if (nodes.isEmpty()) 
        return null;

    // 从后往前取出元素
    String last = nodes.removeLast(); 
    if (last.equals(NULL))
        return null;

    TreeNode root = new TreeNode(Integer.parseInt(last));
    // 先构造右子树，后构造左子树
    root.right = deserialize(nodes);
    root.left = deserialize(nodes);

    return root;
}

# 层序遍历二叉树
void traverse(TreeNode root) {
    if (root == null) 
        return;
    // 初始化队列， 将root加入队列
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();
    q.offer(root); // 将root加入根节点

    while (!q.isEmpty()) {
        TreeNode cur = q.poll(); // 获取并移除队首元素

        /* 层级遍历代码位置 */
        System.out.println(root.val);
        /*****************/

        if (cur.left != null) {
            q.offer(cur.left);
        }

        if (cur.right != null) {
            q.offer(cur.right);
        }
    }
}



# 反序列化过程需要记录空指针null
void traverse(TreeNode root) {
    if (root == null) 
        return null;
    // 初始化队列， 将root加入队列
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();
    q.offer(root);

    while(!q.isEmpty()) {
        TreeNode cur = q.poll(); // 获取当前队首元素

        /* 层级遍历代码位置 */
        if (cur == null) 
            continue; //提前结束本次循环 直接继续执行下次循环
        System.out.println(cur.val);

        q.offer(cur.left);
        q.offer(cur.right);
    }
}

# 层序序列化
String SEP = &quot;,&quot;;
String NULL = &quot;#&quot;;
/* 将二叉树序列化为字符串 */
String serialize(TreeNode root) {
    if (root == null)
        return &quot;&quot;;
    StringBuilder sb = new StringBuilder();
    // 初始化列表，将root加入队列
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();
    q.offer(root);

    while(!q.isEmpty()) {
        TreeNode cur = q.poll();
        /* 层级遍历代码位置 */
        if (cur == null) {
            sb.append(NULL).append(SEP);
            continue;
        }
        sb.append(cur.val).append(SEP);

        q.offer(cur.left);
        q.offer(cur.right);
    }
    return sb.toString();
}

1   2 3   # 4 # #   # #

/* 将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    if (data.isEmpty())
        return null;
    String[] nodes = data.split(SEP);
    // 第一个元素就是root的值
    TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));

    // 队列q记录父节点，将root加入队列
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();
    q.offer(root);

    for (int i=1; i&lt;nodes.length; ) {
        // 队列中存的都是父节点
        TreeNode parent = q.poll();
        // 父节点对应的左侧子节点的值
        String left = nodes[i++];

        if (!left.equals(NULL)) {
            parent.left = new TreeNode(Integer.parseInt(left));
            q.offer(parent.left);
        } else {
            parent.left = null;
        }

        // 父节点对应的右侧子节点的值
        String right = nodes[i++];
        if (!right.equals(NULL)) {
            parent.right = new TreeNode(Integer.parseInt(right));
            q.offer(parent.right);
        } else {
            parent.right = null;
        }
    }
    return root;
}


# 341.扁平化嵌套列表迭代器（中等）
public class NestedInteger {
    // 如果其中存的是一个整数，则返回 true，否则返回 false
    public boolean isInteger();
    // 如果其中存的是一个整数，则返回这个整数，否则返回 null
    public Integer getInteger();
    // 如果其中存的是一个列表，则返回这个列表，否则返回 null
    public List&lt;NestedInteger&gt; getList();
}

public class NestedIterator implements Iterator&lt;Integer&gt; {
    // 构造器输入一个 NestedInteger 列表
    public NestedInteger(List&lt;NestedInteger&gt; nestedList) {}

    // 返回下一个整数
    public Integer next() {}

    // 是否还有下一个元素
    public boolean hasNext() {}
}

N叉树遍历框架
void traverse(TreeNode root) {
    for (TreeNode child : root.children)
        traverse(child);
}



class NestedIterator implements Iterator&lt;Integer&gt; {
    private Iterator&lt;Integer&gt; it;

    public NestedIterator(List&lt;NestedInteger&gt; nestedList) {
        // 存放将nestedList 打平的结果
        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();
        for (NestedInteger node: nestedList) {
            // 以每个节点为根遍历
            traverse(node, result);
        }
        // 得到result列表的迭代器
        this.it = result.iterator();
    }

    public Integer next() {
        return it.next();
    }

    public boolean hasNext() {
        return it.hasNext();
    }

    // 遍历以 root 为根的多叉树，将叶子节点的值加入 result 列表
    private void traverse(NestedInteger root, List&lt;Integer&gt; result) {
        if (root.isInteger()) {
            // 到达叶子节点
            result.add(root.getInteger());
            return;
        }
        // 遍历框架
        for (NestedInteger child : root.getList()) {
            traverse(child, result);
        }
    }
}


public class NestedIterator implements Iterator&lt;Integer&gt; {
    private LinkedList&lt;NestedInteger&gt; list;
    public NestedIterator(List&lt;NestedInteger&gt; nestedList) {
        list = new LinkedList&lt;&gt;(nestedList);
    }

    public Integer next() {
        // hasNext 方法保证了第一个元素一定是整数类型
        return list.remove(0).getInteger();
    }

    public boolean hasNext() {
        // 循环拆分列表元素，直到列表第一个元素是整数类型
        while (!list.isEmpty() &amp;&amp; !list.get(0).isInteger()) {
             // 当列表开头第一个元素是列表类型时，进入循环
            List&lt;NestedInteger&gt; first = list.remove(0).getList();
            // 将第一个列表打平并按顺序添加到开头
            for (int i = first.size() - 1; i &gt;= 0; i--) {
                list.addFirst(first.get(i));
            }
        }
        return !list.isEmpty();
    }
}



#236 二叉树的最近公共祖先
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null) return null;
    if (root == p || root == q) return root;

    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);

    if (left != null &amp;&amp; right != null) {
        return root;
    }

    if (left == null &amp;&amp; right == null) 
        return null;

    return left == null ? right : left;
}



#222.完全二叉树的节点个数（中等）

节点个数   = 前n-1层 + 最后一层
          2^(n-1) - 1  + ?

普通二叉树
public int countNodes(TreeNode root) {
    if (root == null)
        return 0;
    return 1 + countNodes(root.left) + countNodes(root.right);
}


满二叉树
public int countNodes(TreeNode root) {
    int h =  0;
    // 计算树高
    while (root != null) {
        root = root.left;
        h++;
    }
    // 节点总数
    return (int)Math.pow(2, h) - 1;
}


完全二叉树
public int countNodes(TreeNode root) {
    TreeNode l = root, r = root;
    // 记录左右子树的高度
    int hl = 0, hr = 0;
    while (l != null) {
        l = l.left;
        hl++;
    }

    while (r != null) {
        r = r.right;
        hr++;
    }

    // 如果左右子树的高度相同，则是一棵满二叉树
    if (hl == hr) {
        return (int) Math.pow(2, hl) - 1;
    }
    // 如果左右高度不同，则按照普通二叉树的逻辑计算
    return 1 + countNodes(root.left) + countNodes(root.right);
}

// 复杂度分析




动态规划  运筹学的一种最优化方法
一般形式 ：求最值  
核心问题 ：穷举
重叠子问题  暴力穷举效率低下 所以需要备忘录或者DP table来优化穷举过程 避免不必要的计算
动态规划具备最优子结构
只有列出正确的状态转移方程才能正确的穷举

明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义。

# 重叠子问题 -&gt; 斐波那契数列
int fib(int N) {
    if (N &lt; 1) 
        return 0;
    // 备忘录全初始化为0
    vector&lt;int&gt; memo(N+1, 0);
    // 进行带备忘录的递归
    return helper(memo, N);
}

# 自顶向下
int helper(vector&lt;int&gt;&amp; memo, int n) {
    // base case
    if (n == 1 || n == 2)
        return 1;
    // 如果已经计算过 直接返回
    if (memo[n] != 0) {
        return memo[n];
    } 
    // 否则递归计算
    memo[n] = helper(memo, n-1) + helper(memo, n-2);
    return memo[n];
}

# 动态规划 自底向上 循环迭代
int fib(int N) {
    if (N &lt; 1)
        return 0;
    if (N == 1 || N == 2) 
        return 1;

    vector&lt;int&gt; dp(N+1, 0);
    // base case
    dp[1] = dp[2] = 1;
    for (int i=3; i&lt;=N; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[N];
}

# 优化空间复杂度 dp table
int fib(int n) {
    if (n &lt; 1) 
        return 0;
    if (n == 1 || n == 2) 
        return 1;

    int prev = 1, curr = 1;
    for (int i=3; i&lt;=n; i++) {
        int sum = prev + curr;
        prev = curr;
        curr = sum;
    }
    return curr;
}


# 凑零钱问题
1. 确定base case 
2. 确定状态 问题中会变化的量
3. 确定选择
4. 明确dp数组的定义


# 暴力递归
def coinChange(coins: List[int], amout: int):

    def dp(n):
        # base case
        if n == 0: return 0;
        if n &lt; 0: return -1;
        # 求最小值，所以初始化为正无穷
        res = float(&apos;INF&apos;)

        for coin in coins:
            subproblem = dp(n - coin)
            # 子问题无解，跳过
            if subproblem == -1:
                continue
            res = min(res, 1 + subproblem)

        return res if res != float(&apos;INF&apos;) else -1

    return dp(amount)



# 带备忘录的递归
def coinChange(coins: List[int], amount: int):
    # 备忘录
    memo = dict()

    def dp(n):
        # 查备忘录, 避免重复计算
        if n in memo:
            return memo[n]

        # base case
        if n == 0:
            return 0
        if n &lt; 0:
            return -1
        res = float(&apos;INF&apos;)
        for coin in coins:
            subproblem = dp(n - coin)
            if subproblem == -1:
                continue
            res = min(res, 1 + subproblem)

        # 记入备忘录
        memo[n] = res if res != float(&apos;INF&apos;) else -1
        return memo[n]

    return dp(amount)

# dp数组的迭代解法
int coinChange(vector&lt;int&gt;&amp; coins, int amount) {
    // 数组大小为 amount + 1，初始值也为 amount + 1
    vector&lt;int&gt; dp(amount+1, amount+1);
    // base case
    dp[0] = 0;
    // 外层 for 循环遍历所有状态的所有取值
    for (int i=0; i&lt;dp.size(); i++) {
        // 内层 for 循环在求所有选择的最小值
        for(int coin: coins) {
            // 子问题无解，跳过
            if (i - coin &lt; 0) 
                continue
            // 选或不选
            dp[i] = min(dp[i], 1 + dp[i-coin]); 
        }
    }
    return (dp[amount] == amount+1) ? -1 : dp[amount];
}


# 最优子结构 子问题之间必须相互独立
动态规划 = 最优子结构 + 重叠子问题
暴力递归解 -&gt; 优化（备忘录） -&gt; dp数组迭代

dp数组
    1. 明确dp数组的含义
    2. 定义base case
    3. 找状态转移方程

遍历dp数组
1、遍历的过程中，所需的状态必须是已经计算出来的。
2、遍历的终点必须是存储结果的那个位置。

# 最长公共子序列
    1. dp[i][j]的含义是：对于s1[1..i]和s2[1..j]，它们的LCS长度是dp[i][j]
    2. base case  索引为0的行或列表示空串
    3. 找状态转移方程

    # 暴力递归
    def longestCommonSubsequence(str1, str2) -&gt; int:
        def dp(i, j):
            # 空串的base case
            if i == -1 or j == -1:
                return 0;
            if str1[i] == str2[j]:
                # 找到一个lcs元素，继续往前找
                return dp(i-1, j-1) + 1
            else:  # 当前不是lcs元素
                # 谁能让lcs最长，就听谁的
                return max(dp(i-1, j), dp(i, j-1))
        # i和j初始化为最后一个索引
        return dp(len(str1)-1, len(str2)-1)

    # dp table 自底向上迭代
    def longestCommonSubsequence(str1, str2) -&gt; int:
        m, n = len(str1), len(str2)
        #  构建DP table 和 base case
        dp = [[0] * (n+1) for _ in range(m+1)]
        # 进行状态转移
        for i in range(1, m+1):
            for j in range(1, n+1):
                if str1[i-1] == str2[j-1]:
                    dp[i][j] = 1 + dp[i-1][j-1]
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])

        return dp[m][n]



# 编辑距离
DNA相似度
horse -&gt; ros
intention -&gt; execution
rad -&gt; apple

s1 -&gt; s2

if s1[i] == s2[j]:
    skip
    i,j同时向前移动
else:
    3选1
        insert
        delete
        replace

def minDistance(s1, s2) -&gt; int:
    # 返回s1[0..i] 和 s2[0..j]的最小编辑距离
    def dp(i, j):
        # base case是i走完s1, j走完s2, 直接返回另一个字符串剩下的长度
        if i == -1: return j+1
        if j == -1: return i+1

        if s1[i] == s2[j]:
            return dp(i-1, j-1) # skip
        else:
            return min(
                dp(i, j-1) + 1,  # 插入
                dp(i-1, j) + 1,  # 删除
                dp(i-1, j-1) + 1, # 替换
                )

        # i,j 初始化指向最后一个索引
        return dp(len(s1)-1, len(s2)-1)


dp[i-1][j-1]存储s1和s2的最小编辑距离

int minDistance(String s1, String s2) {
    int m = s1.length, n = s2.length();
    int[][] dp = new int[m+1][n+1];
    // base case
    for (int i=1; i&lt;m; i++) {
        dp[i][0] = i;
    }
    for (int j=1; j&lt;n; j++) {
        dp[0][j] = j;
    }
    // 自底向上求解
    for (int i=1; i&lt;=m; i++) {
        for (int j=1; j&lt;=n; j++) {
            if (s1.charAt(i-1) == s2.charAt(j-1)) 
                dp[i][j] = dp[i-1][j-1];
            else
                dp[i][j] = min(
                    dp[i-1][j] + 1,
                    dp[i][j-1] + 1,
                    dp[i-1][j-1] + 1
                    );
        }
    }
    return dp[m][n];
}

int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}



# 数学归纳法
最长递增子序列 1维
dp[i] 表示以nums[i]这个数结尾的最长递增子序列的长度

public int lengthOfLTS(int[] nums) {
    int[] dp = new int[nums.length];
    // dp数组全都初始化为1
    Arrays.fill(dp, 1);
    for (int i=1; i&lt;nums.length; i++) {
        for (int j=0; j&lt;i; j++) {
            if (nums[j] &lt; nums[i]) 
            dp[i] = Math.max(dp[i], dp[j]+1);
        }
    }

    int res = 0;
    for (int i=0; i&lt;dp.length; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}


# 最长回文子串
String palindrome(String s, int l, int r) {
    // 防止索引越界
    while(l &gt;=0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] == s[r]) {
        // 向两边展开
        l--;
        r++;
    }
    return s.substr(l+1, r-l-1);
}

String longestPalindrome(String s) {
    String res;
    for (int i=0; i&lt;s.size(); i++) {
        // 以s[i]为中心的最长回文子串
        String s1 = palindrome(s, i, i);
        //     以s[i] 和 s[i+1] 为中心的最长回文子串
        String s2 = palindrome(s, i, i+1);
        res = res.size() &gt; s1.size()? res : s1;
        res = res.size() &gt; s2.size()? res : s2;
    }
    return res;
}



# 最长回文子序列 2维
dp数组的定义 : 在子串s[i..j]中，最长回文子序列的长度为dp[i][j]
要求的是dp[0][n-1]


int longestpalindromeSubseq(string s) {
    int n = s.size();
    // dp 数组全部初始化为0
    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n,0));
    // base case
    for (int i=0; i&lt;n; i++) {
        dp[i][i] = 1;
    }
    // 反着遍历保证正确的状态转移
    for (int i=n-2; i&gt;=0; i--) {
        for (int j=i+1; j&lt;n; j++) {
            // 状态转移方程
            if (s[i] == s[j])
                dp[i][j] = dp[i+1][j-1] + 2;
            else
                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
        }
    }
    // 整个s的最长回文子串长度
    return dp[0][n-1];
}    
















</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>




          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/cosmos_dna.jpg"
                alt="Vincent Zhang" />
            
              <p class="site-author-name" itemprop="name">Vincent Zhang</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry, Stay Foolish.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/VincentCheungKokomo" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/xia-luo-te-de-wang-79" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="Title" target="_blank">Title</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vincent Zhang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'CkjKMo6dKnmxFnoBz1trtBsk-gzGzoHsz',
        appKey: 'z0LNvVeEtdOgcUB3xht2TzSn',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
