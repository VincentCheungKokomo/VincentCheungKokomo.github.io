<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2021/02/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/02/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>date 显示服务器时间<br>cal 显示日历</p><p>文件系统<br>root /根目录<br>cd / 跳到根目录<br>ls 查看当前文件<br>ls -l 查看当前文件详细信息<br>    第一个字母d 表示目录<br>    第一个字母- 表示文件</p><hr><p>clear 清除当前窗口<br>cd .. 退回到上层文件夹<br>mkdir tutorial 新建文件夹<br>rmdir tutorial 删除文件夹<br>cp file1.txt file2.txt 拷贝file1.txt到file2.txt</p><hr><p>cat filename 查看文件内容<br>diff file1 file2 比较文件差异<br>head（file2.txt -n 1） 查看文件的前几行<br>tail（file2.txt -n 1） 查看文件的后几行</p><hr><p>word count<br>wc file2.txt 结果 行数 单词数 多少字节<br>wc -l file2.txt 只查看行数<br>wc -w file2.txt 只查看单词数<br>wc -c file2.txt 只查看字节数</p><h2 id="rm-filename-删除文件-不可撤销"><a href="#rm-filename-删除文件-不可撤销" class="headerlink" title="rm filename 删除文件 不可撤销"></a>rm filename 删除文件 不可撤销</h2><p>mv<br>修改文件名<br>    mv file1.txt helloworld.txt<br>移动文件<br>    mv helloworld.txt CTutorial/</p><p>less filename.txt 只显示文档file的一部分 然后用上下箭头来翻动<br>使用q来退出</p><hr><p>chmod命令 更改权限<br>三段<br>u作者 g小组 o其他<br>rwx   rwx    rwx<br>110<br>二进制表示也行<br>读/写/运行</p><p>chmod u-r file2.txt 作者权限减r(不可读<br>chmod u+r file2.txt 恢复可读权限<br>chmod go-r file2.txt 除作者外其他人都不能读<br>chmod 444 全部可读</p><hr><p>grep命令 用于对文本文件进行搜索<br>grep France paris.txt 在paris.txt是否有France<br>grep a paris.txt  所有包含字母a的单词 正则表达式<br>grep a* paris.txt  字母a出现任意次的单词<br>grep aa* paris.txt  字母a至少出现一次的单词</p><p>grep ^F paris.txt 以F开头<br>grep d.g paris.txt  .通配符<br>grep d[oi]g paris.txt  [o或者i]<br>grep d[A-Za-z]g paris.txt [A-Za-z]任意英文字母</p><p>命令组合<br>查找并计数<br>grep d[A-Za-z]g paris.txt | wc</p><hr><p>zip 文件压缩<br>zip CProgram.zip * 压缩当前文件夹的内容到CProgram<br>unzip解压</p><p>tar<br>压缩<br>tar -zcvf CTut.tar.gz Ctutorial/<br>解压<br>tar -zxvf CTut.tar.gz</p><hr><p>下载<br>wget URL -O filename</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2021/02/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/02/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VS code</title>
      <link href="/2020/12/19/VS-code/"/>
      <url>/2020/12/19/VS-code/</url>
      
        <content type="html"><![CDATA[<p>C++环境</p><p>python环境</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>labuladong_数据结构</title>
      <link href="/2020/12/18/labuladong-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/12/18/labuladong-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单链表节点的结构</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    ListNode(int x) &#123;</span><br><span class="line">        val &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h2><h3 id="1-递归反转整个链表"><a href="#1-递归反转整个链表" class="headerlink" title="1. 递归反转整个链表"></a>1. 递归反转整个链表</h3><p>明确递归函数的定义： 输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverse(ListNode head) &#123;</span><br><span class="line">    if (head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode last &#x3D; reverse(head.next);</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line">    head.next &#x3D; null;</span><br><span class="line">    return last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-反转链表前N个节点"><a href="#2-反转链表前N个节点" class="headerlink" title="2.  反转链表前N个节点"></a>2.  反转链表前N个节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将链表的前 n 个节点反转（n &lt;&#x3D; 链表长度）</span><br><span class="line">ListNode successor &#x3D; null; &#x2F;&#x2F; 后继节点</span><br><span class="line">&#x2F;&#x2F; 反转以head为起点的n个节点， 返回新的头节点</span><br><span class="line">ListNode reverseN(ListNode head, int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 记录n+1个节点</span><br><span class="line">        successor &#x3D; head.next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 以head.next为起点， 需要反转前n-1个节点</span><br><span class="line">    ListNode last &#x3D; reverseN(head.next, n-1);</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line">    &#x2F;&#x2F; 让反转后的head节点和后面的节点连起来</span><br><span class="line">    head.next &#x3D; successor;</span><br><span class="line">    return last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-反转链表的一部分"><a href="#3-反转链表的一部分" class="headerlink" title="3. 反转链表的一部分"></a>3. 反转链表的一部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverseBetween(ListNode head, int m, int n) &#123;</span><br><span class="line">    &#x2F;&#x2F; base case</span><br><span class="line">    if (m &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 相当于反转前 n 个元素</span><br><span class="line">        return reverseN(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 前进到反转的起点触发 base case</span><br><span class="line">    head.next &#x3D; reverseBetween(head.next, m-1, n-1);</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>// 反转以 a 为头结点的链表<br>ListNode reverse(ListNode a) {<br>    ListNode pre, cur, nxt;<br>    pre = null; cur = a; nxt = a;<br>    while (cur != null) {<br>        nxt = cur.next;<br>        // 逐个节点反转<br>        cur.next = pre;<br>        // 更新指针位置<br>        pre = cur; // 最后的值为最后的节点<br>        cur = nxt; // 最后的值为NULL<br>    }<br>    // 返回反转后的头节点<br>    return pre;<br>}</p><p>/** 反转区间 [a, b) 的元素，注意是左闭右开 */<br>ListNode reverse(ListNode a, ListNode b) {<br>    ListNode pre, cur, nxt;<br>    pre = null; cur = a, nxt = a;<br>    while (cur != b) {<br>        nxt = cur.next;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = nxt;<br>    }<br>    return pre;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line"></span><br><span class="line">### 25.k个一组反转链表</span><br></pre></td></tr></table></figure><p>ListNode reverseKGroup(ListNode head, int k) {<br>    if (head == null) return null;<br>    // 区间 [a, b) 包含 k 个待反转元素<br>    ListNode a, b;<br>    a = b = head;<br>    for (int i = 0 ; i &lt; k ; i++) {<br>        // 不足k个， 不需要反转， base case<br>        if (b == null)<br>            return head;<br>        b = b.next;<br>    }<br>    // 反转前k个元素<br>    ListNode newHead = reverse(a, b);<br>    // 递归反转后续链表并连接起来<br>    a.next = reverseKGroup(b, k);<br>    return newHead;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">------------------</span><br><span class="line"></span><br><span class="line">### 判断回文字符串</span><br></pre></td></tr></table></figure><p>boolean isPalindrome(String s) {<br>    int left = 0, right = s.length - 1;<br>    while (left &lt; right) {<br>        if (s[left] != s[right])<br>            return false;<br>        left++;<br>        right–;<br>    }<br>    return true;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 234判断回文单链表</span><br><span class="line">单链表无法倒着遍历， 无法使用双指针技巧</span><br><span class="line">将原始链表反转后存入一条新的链表， 然后比较这两条链表是否相同</span><br></pre></td></tr></table></figure><p>boolean isPalindrome(ListNode head) {</p><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 二叉树的遍历方式</span><br></pre></td></tr></table></figure><p>void traverse(TreeNode root) {<br>    // 前序遍历代码<br>    traverse(root.left)<br>    // 中序遍历代码<br>    traverse(root.right)<br>    // 后序遍历代码<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">####链表的前序遍历和后序遍历</span><br></pre></td></tr></table></figure><p>void traverse(ListNode head) {<br>    // 前序遍历代码<br>    traverse(head.next);<br>    // 后序遍历代码<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;* 倒序打印单链表中的元素值 *&#x2F;</span><br></pre></td></tr></table></figure><p>void traverse(ListNode head) {<br>    if (head == null) return;<br>    traverse(head.next);<br>    // 后序遍历代码<br>    print(head.val);<br>}</p><pre><code>模仿双指针实现回文判断的功能：ListNode left;boolean isPalindrome(ListNode head) {    left = head;    return traverse(head);}boolean traverse(ListNode right) {    if (right == null) return true;    boolean res = traverse(right.next);    // 后序遍历代码    res = res &amp;&amp; (right.val == left.val);    left = left.next;    return res;}####优化空间复杂度ListNode slow, fast;slow = fast = head;while (fast != null &amp;&amp; fast.next != null) {    slow = slow.next;    fast = fast.next.next;}// slow 指针现在指向链表中点if (fast != null)    slow = slow.next;ListNode left = head;ListNode right = reverse(slow);while (right != null) {}二叉树遍历框架/* 二叉树遍历框架 */void traverse(TreeNode root) {    // 前序遍历    traverse(root.left)    // 中序遍历    traverse(root.right)    // 后序遍历}快速排序void quicksort(int[] nums, int lo, int hi) {    /****** 前序遍历位置 ******/    // 通过交换元素构建分界点 p    int p = partition(nums, lo, hi);    /*****************/    quicksort(nums, lo, p-1);    quicksort(nums, p+1, hi);}归并排序void sort(int[] nums, int lo, int hi) {    int mid = (lo + hi) / 2;    sort(nums, lo, mid);    sort(nums, mid, hi);    /****** 后序遍历位置 ******/    // 合并两个排好序的子数组    merge(nums, lo, mid, hi);}只要涉及到递归，都可以抽象成二叉树的问题写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。计算一棵二叉树共有几个节点：// 定义：count(root) 返回以 root 为根的树有多少节点int count(TreeNode root) {    // base case    if (root == null) return 0;    // 自己加上子树的节点数就是整棵树的节点数    return 1 + count(root.left) + count(root.right);}# 226.翻转二叉树（简单）我们发现只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树。TreeNode invertTree(TreeNode root) {    // base case    if (root == null)        return null;    /*****前序遍历位置***********/     // root 节点需要交换它的左右子节点    TreeNode tmp = root.left;    root.left = root.right;    root.right = tmp;    // 让左右子节点继续翻转它们的子节点    invertTree(root.left);    invertTree(root.right);    return root;}# 116.填充每个节点的下一个右侧节点指针（中等）// Node connect(Node root) {//     if (root == null || root.left == null) {//         return root;//     }//     root.left.next = root.right;  // 连接每个节点的左右子节点//     connect(root.left);//     connect(root.right);//     return root;// }// 主函数Node connect(Node root) {    if (root == null)         return null;    connectTwoNode(root.left, root.right);    return root;}// 辅助函数void connectTwoNode(Node node1. Node node2) {    if (node1 == null || node2 == null) {        return;    }    /***前序遍历位置 ******/    // 将传入的两个节点连接    node1.next = node2;    // 连接相同父节点的两个子节点    connectTwoNode(node1.left, node1.right);    connectTwoNode(node2.left, node2.right);    // 连接跨越父节点的两个子节点    connectTwoNode(node1.right, node2.left);}# 114.二叉树展开为链表（中等）// 定义：将以 root 为根的树拉平为链表void flatten(TreeNode root) {    // base case    if (root == null) return;    // 将 root 的左子树和右子树拉平。    flatten(root.left);    flatten(root.right);    /******后序遍历位置******/    // 1、左右子树已经被拉平成一条链表    TreeNode left = root.left;    TreeNode right = root.right;    // 2、将左子树作为右子树    root.left = null;    root.right = left;    // 3、将 root 的右子树接到左子树(当前右子树)下方，然后将整个左子树作为右子树。    TreeNode p = root;    while (p.right != null) {        p = p.right;        }    p.right = right; // 将 root 的右子树接到左子树}#654.最大二叉树（中等）int[] nums = [3,2,1,6,0,5];reeNode constructMaximumBinaryTree(int[] nums) {    return build(nums, 0, nums.length-1);}// 构造二叉树TreeNode build(int[] nums, int lo, int hi) {    // base case    if (lo &gt; hi) {        return null;    }    // 找出数组中的最大值和对应的索引    int maxVal = Integer.MIN_VALUE;    int index = -1;    for (int i=lo; i&lt;=hi; i++) {        if(nums[i] &gt; maxVal) {            maxVal = nums[i];            index = i;        }    }    // 构造根节点    TreeNode root = new TreeNode(maxVal);    // 递归调用构造左右子树    root.left = build(nums, lo, index-1);    root.right = build(nums, index+1, hi);    return root;}#105.从前序与中序遍历序列构造二叉树（中等）// 1. 从前序遍历结果中找到root// 2. 根据root的值，在中序遍历结果找到root的索引index// 3. 根据索引index, 把中序数组分为左右两部分left, right// 4. 在左右两部分递归 1，2，3/* 主函数 */TreeNode buildTree(int[] preorder, int[] inorder) {    return build(preorder, 0, preorder.length - 1,                 inorder, 0, inorder.length - 1);}/*    若前序遍历数组为 preorder[preStart..preEnd]，   后续遍历数组为 postorder[postStart..postEnd]，   构造二叉树，返回该二叉树的根节点 */TreeNode build(int[] preorder, int preStart, int preEnd,                int[] inorder, int inStart, int inEnd) {    if (preStart &gt; preEnd) {        return null;    }    // root 节点对应的值就是前序遍历数组的第一个元素    int rootVal = preorder[preStart];    // rootVal 在中序遍历数组中的索引    int index = 0;    for (int i = inStart; i &lt;= inEnd; i++) {        if (inorder[i] == rootVal) {            index = i;            break;        }    }    int leftSize = index - instart;    TreeNode root = new TreeNode(rootVal);    // 递归构造左右子树    root.left = build(preorder, preStart+1, preStart+leftsize,                      inorder, instart, index-1);    root.right = build(preorder, preStart+leftSize+1, preEnd,                       inorder, index+1, inEnd);    return root;}#106.从中序与后序遍历序列构造二叉树（中等）TreeNode buildTree(int[] inorder, int[] postorder) {    return build(inorder, 0, inorder.length - 1,         postorder, 0, postorder.lenght - 1);}TreeNode build(int[] inorder, int inStart, int inEnd,     int[] postorder, int postStart, int postEnd) {    // root 节点对应的值就是后序遍历数组的最后一个元素    int rootVal = postorder[postEnd];    // rootVal 在中序遍历数组中的索引    int index = 0;    for (int i = inStart; i &lt;= inEnd; i++) {         if (inorder[i] == rootVal) {             index = i;             break;         }    }     TreeNode root = new TreeNode(rootVal);    int leftSize = index - inStart; // 左半部分的大小    // 递归构造左右子树    root.left = build(inorder, inStart, index-1,                     postorder, postStart, postStart+leftsize-1);    root.right = build(inorder, index+1, inEnd,        postorder, postStart+leftSize, postEnd-1);    return root;}做二叉树的问题，关键是把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了。#652.寻找重复的子树（中等）重复子树：具有相同的结构以及相同的节点值// 记录所有子树 HashSet&lt;String&gt; memo = new HashSet&lt;&gt;();// 记录重复的子树根节点  使用Hashset的话 res的结果会重复 LinkedList&lt;TreeNode&gt; res = new LinkedList&lt;&gt;();// 通过拼接字符串的方式把二叉树序列化String traverse(TreeNode root) {    // 对于空节点，可以用一个特殊字符表示    if (root == null) {        return &apos;#&apos;;    }    // 将左右子树序列化成字符串    String left = traverse(root.left);    String right = traverse(root.right);    /* 后序遍历代码位置 */    // 左右子树加上自己，就是以自己为根的二叉树序列化结果    String subTree = left + &quot;,&quot;+ root.val + &quot;,&quot; + right;    if (memo.contains(subTree)) {        res.add(root);     } else {        memo.add(subTree);     }    return subTree;}List&lt;TreeNode&gt; findDuplicateSubtrees(TreeNode root) {    traverse(root);    // 当前节点该做什么？    // 当前节点子树的结构 // 树序列化    // 与其他节点子树进行比较    return res;}// 记录所有子树以及出现的次数HashMap&lt;String, Integer&gt; memo = new HashMap&lt;&gt;();// 记录重复的子树根节点LinkedList&lt;TreeNode&gt; res = new  LinkedList&lt;&gt;();/* 主函数 */List&lt;TreeNode&gt; findDuplicatedSubtrees(TreeNode root) {    traverse(root);    return res;}/* 辅助函数 */String traverse(TreeNode root) {    // 对于空节点，可以用一个特殊字符表示    if (root == null) {        return &apos;#&apos;;    }    // 将左右子树序列化成字符串    String left = traverse(root.left);    String right = traverse(root.right);    /* 后序遍历代码位置 */    // 左右子树加上自己，就是以自己为根的二叉树序列化结果    String subTree = left + &quot;,&quot;+ root.val + &quot;,&quot; + right;    int freq = memo.getOrDefault(subTree, 0);    // 多次重复也只会被加入结果集一次    if (freq == 1) {        res.add(root);    }    // 给子树对应的出现次数加1    memo.put(subTree, freq + 1);    return subTree;}二叉搜索树 BSTAVL树 红黑树 B+树 线段树中序遍历是有序的void traverse(TreeNode root) {    if (root == null) return;    traverse(root.left);    // 中序遍历位置    print(root.val);    traverse(root.right);}#230 二叉搜索树中第k小的元素int kthSmallest(TreeNode root, int k) {    // 利用BST的中序遍历特性    inorder(root, k);    return res;}// 记录结果int res = 0;// 记录当前元素的排名int rank = 0;void inorder(TreeNode root, int k) {    if (root == null) {        return;    }    inorder(root.left, k);    /* 中序遍历代码位置 */    rank++;  // 真正访问根节点的时候 rank+1    if (k == rank) {        // 找到第k小的元素        res = root.val;        return;    }    inorder(root.right, k);}已知节点数的二叉搜索树节点 class TreeNode {    int  val;    int size; // 以该节点为根的树节点总数    TreeNode left;    TreeNode right;}#538 二叉搜索树转换为累加树降序打印节点的值void postorder(TreeNode root) {    if (root == null) return;    // 先递归遍历右子树    postorder(root.right);    print(root.val);    // 后递归遍历左子树    postorder(root.left);}TreeNode convert(TreeNode root) {    postorder(root);    return root;}int sum = 0; // 记录累加和void postorder(TreeNode root) {    if (root == null) return;    postorder(root.right);    sum += root.val;    // 将BST转化成累加树    root.val = sum;     postorder(root.left);}BST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，要么利用中序遍历的特性满足题目的要求，也就这么些事儿吧。#98.验证二叉搜索树（中等）boolean isValidBST(TreeNode root) {    return isValidBST(root, null, null);}/* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val */boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {    // base case    if (root == null) return true;    // 若root.val不符合min max的限制，说明不是合法BST    if (min != null &amp;&amp; root.val &lt;= min.val) return false;    if (max != null &amp;&amp; root.val &gt;= max.val) return false;     // 限定左子树的最大值是root.val, 右子树的最小值是root.val    return isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);}#700.二叉搜索树中的搜索（简单）boolean isInBST(TreeNode root, int target) {    if (root == null) return false;    if (target == root.val)         return true;    else if (target &lt; root.val) {        return isInBST(root.left, target);    } else {        return isInBST(root.right, target);    }}// BST 的遍历框架void BST(TreeNode root, int target) {    if (target == root.val)         // do something    else if (target &lt; root.val) {        BST(root.left, target);    } else {        BST(root.right, target);    }}#701.二叉搜索树中的插入操作（中等）遍历（找） + 访问（改）找插入位置 插入TreeNode insertIntoBST(TreeNode root, int val) {    // 找到空位置插入新节点    if (root == null) return new TreeNode(val);    if (val &lt; root.val) {        root.left = insertIntoBST(root.left, int val);    } else if (val &gt; root.val) {        root.right = insertIntoBST(roor.right, int val);    } else {        // pass    }    return root;}#450.删除二叉搜索树中的节点（中等）先找再改TreeNode deleteNode(TreeNode root, int key) {    if (root.val == key) {        // 找到了， 进行删除        if (root.left == null &amp;&amp; root.right == null)             return null;        else if (root.left == null)            return root.right;        else if (root.right == null)            return root.left;        else {            // 找到左子树最大的节点，或右子树最小的节点            TreeNode minNode = getMin(root.right);            // 把root 改成 minNode            root.val = minNode.val;            // 转而去右子树删除 minNode            root.right = deleteNode(root.right, minNode.val);        }    } else if (key &lt; root.val) {        // 去左子树找        root.left = deleteNode(root.left, key);    } else {        root.right = deleteNode(root.right, key);    }    return root;}TreeNode getMin(TreeNode node) {    // BST 最左边的就是最小的    while (node.left != null) node = node.left;    return node;}#297.二叉树的序列化和反序列化（困难）public class Codec {    // 把一棵二叉树序列化成字符串    public String serialize(TreeNode root) {}    // 把字符串反序列化成二叉树    public TreeNode deserialize(String data) {}}# 序列化// 代表分隔符的字符String SEP = &quot;,&quot;;// 代表null空指针的字符String NULL = &quot;#&quot;;/* 主函数，将二叉树序列化为字符串 */String serialize(TreeNode root) {    // 用于拼接字符串    StringBuilder sb = new StringBuilder();            serialize(root, sb);    return sb.toString();}# 前序/* 辅助函数，将二叉树存入 StringBuilder */void serialize(TreeNode root, StringBuilder sb) {    if (root == null) {        sb.append(NULL).append(SEP);        return;    }    /****** 前序遍历位置 ******/    sb.append(root.val).append(SEP);    /***********************/    serialize(root.left, sb);    serialize(root.right, sb);}# 后序void serialize(TreeNode root, StringBuilder sb) {    if (root == null) {        sb.append(NULL).append(SEP);        return;    }    serialize(root.left, sb);    serialize(root.right, sb);    /****** 后序遍历位置 ******/    sb.append(root.val).append(SEP);    /***********************/}字符串转列表String data = &quot;1,2,#,4,#,#,3,#,#,&quot;;String[] nodes = data.split(&quot;,&quot;);nodes: 1 -&gt; 2 -&gt; # -&gt; 4 -&gt; # -&gt; # -&gt; 3 -&gt; # -&gt; # # 反序列化/* 主函数，将字符串反序列化为二叉树结构 */TreeNode deserialize(String data) {    // 将字符串转换成列表    LinkedList&lt;String&gt; nodes = new LinkedList&lt;&gt;();    for (String s : data.split(SEP)) {        nodes.addLast(s);    }    return deserialize(nodes);}# 前序/* 辅助函数，通过 nodes 列表构造二叉树 */TreeNode deserialize(LinkedList&lt;String&gt; nodes) {    if (nodes.isEmpty())         return null;    /****** 前序遍历位置 ******/    // 列表最左侧就是根节点    String first = nodes.removeFirst();    if (first.equals(NULL))         return null;    // 字符串解析为整型    TreeNode root = new TreeNode(Integer.parseInt(first));    root.left = deserialize(nodes);    root.right = deserialize(nodes);    return root;}# 后序/* 辅助函数，通过 nodes 列表构造二叉树 */TreeNode deserialize(LinkedList&lt;String&gt; nodes) {    if (nodes.isEmpty())         return null;    // 从后往前取出元素    String last = nodes.removeLast();     if (last.equals(NULL))        return null;    TreeNode root = new TreeNode(Integer.parseInt(last));    // 先构造右子树，后构造左子树    root.right = deserialize(nodes);    root.left = deserialize(nodes);    return root;}# 层序遍历二叉树void traverse(TreeNode root) {    if (root == null)         return;    // 初始化队列， 将root加入队列    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();    q.offer(root); // 将root加入根节点    while (!q.isEmpty()) {        TreeNode cur = q.poll(); // 获取并移除队首元素        /* 层级遍历代码位置 */        System.out.println(root.val);        /*****************/        if (cur.left != null) {            q.offer(cur.left);        }        if (cur.right != null) {            q.offer(cur.right);        }    }}# 反序列化过程需要记录空指针nullvoid traverse(TreeNode root) {    if (root == null)         return null;    // 初始化队列， 将root加入队列    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();    q.offer(root);    while(!q.isEmpty()) {        TreeNode cur = q.poll(); // 获取当前队首元素        /* 层级遍历代码位置 */        if (cur == null)             continue; //提前结束本次循环 直接继续执行下次循环        System.out.println(cur.val);        q.offer(cur.left);        q.offer(cur.right);    }}# 层序序列化String SEP = &quot;,&quot;;String NULL = &quot;#&quot;;/* 将二叉树序列化为字符串 */String serialize(TreeNode root) {    if (root == null)        return &quot;&quot;;    StringBuilder sb = new StringBuilder();    // 初始化列表，将root加入队列    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();    q.offer(root);    while(!q.isEmpty()) {        TreeNode cur = q.poll();        /* 层级遍历代码位置 */        if (cur == null) {            sb.append(NULL).append(SEP);            continue;        }        sb.append(cur.val).append(SEP);        q.offer(cur.left);        q.offer(cur.right);    }    return sb.toString();}1   2 3   # 4 # #   # #/* 将字符串反序列化为二叉树结构 */TreeNode deserialize(String data) {    if (data.isEmpty())        return null;    String[] nodes = data.split(SEP);    // 第一个元素就是root的值    TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));    // 队列q记录父节点，将root加入队列    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();    q.offer(root);    for (int i=1; i&lt;nodes.length; ) {        // 队列中存的都是父节点        TreeNode parent = q.poll();        // 父节点对应的左侧子节点的值        String left = nodes[i++];        if (!left.equals(NULL)) {            parent.left = new TreeNode(Integer.parseInt(left));            q.offer(parent.left);        } else {            parent.left = null;        }        // 父节点对应的右侧子节点的值        String right = nodes[i++];        if (!right.equals(NULL)) {            parent.right = new TreeNode(Integer.parseInt(right));            q.offer(parent.right);        } else {            parent.right = null;        }    }    return root;}# 341.扁平化嵌套列表迭代器（中等）public class NestedInteger {    // 如果其中存的是一个整数，则返回 true，否则返回 false    public boolean isInteger();    // 如果其中存的是一个整数，则返回这个整数，否则返回 null    public Integer getInteger();    // 如果其中存的是一个列表，则返回这个列表，否则返回 null    public List&lt;NestedInteger&gt; getList();}public class NestedIterator implements Iterator&lt;Integer&gt; {    // 构造器输入一个 NestedInteger 列表    public NestedInteger(List&lt;NestedInteger&gt; nestedList) {}    // 返回下一个整数    public Integer next() {}    // 是否还有下一个元素    public boolean hasNext() {}}N叉树遍历框架void traverse(TreeNode root) {    for (TreeNode child : root.children)        traverse(child);}class NestedIterator implements Iterator&lt;Integer&gt; {    private Iterator&lt;Integer&gt; it;    public NestedIterator(List&lt;NestedInteger&gt; nestedList) {        // 存放将nestedList 打平的结果        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();        for (NestedInteger node: nestedList) {            // 以每个节点为根遍历            traverse(node, result);        }        // 得到result列表的迭代器        this.it = result.iterator();    }    public Integer next() {        return it.next();    }    public boolean hasNext() {        return it.hasNext();    }    // 遍历以 root 为根的多叉树，将叶子节点的值加入 result 列表    private void traverse(NestedInteger root, List&lt;Integer&gt; result) {        if (root.isInteger()) {            // 到达叶子节点            result.add(root.getInteger());            return;        }        // 遍历框架        for (NestedInteger child : root.getList()) {            traverse(child, result);        }    }}public class NestedIterator implements Iterator&lt;Integer&gt; {    private LinkedList&lt;NestedInteger&gt; list;    public NestedIterator(List&lt;NestedInteger&gt; nestedList) {        list = new LinkedList&lt;&gt;(nestedList);    }    public Integer next() {        // hasNext 方法保证了第一个元素一定是整数类型        return list.remove(0).getInteger();    }    public boolean hasNext() {        // 循环拆分列表元素，直到列表第一个元素是整数类型        while (!list.isEmpty() &amp;&amp; !list.get(0).isInteger()) {             // 当列表开头第一个元素是列表类型时，进入循环            List&lt;NestedInteger&gt; first = list.remove(0).getList();            // 将第一个列表打平并按顺序添加到开头            for (int i = first.size() - 1; i &gt;= 0; i--) {                list.addFirst(first.get(i));            }        }        return !list.isEmpty();    }}#236 二叉树的最近公共祖先TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {    if (root == null) return null;    if (root == p || root == q) return root;    TreeNode left = lowestCommonAncestor(root.left, p, q);    TreeNode right = lowestCommonAncestor(root.right, p, q);    if (left != null &amp;&amp; right != null) {        return root;    }    if (left == null &amp;&amp; right == null)         return null;    return left == null ? right : left;}#222.完全二叉树的节点个数（中等）节点个数   = 前n-1层 + 最后一层          2^(n-1) - 1  + ?普通二叉树public int countNodes(TreeNode root) {    if (root == null)        return 0;    return 1 + countNodes(root.left) + countNodes(root.right);}满二叉树public int countNodes(TreeNode root) {    int h =  0;    // 计算树高    while (root != null) {        root = root.left;        h++;    }    // 节点总数    return (int)Math.pow(2, h) - 1;}完全二叉树public int countNodes(TreeNode root) {    TreeNode l = root, r = root;    // 记录左右子树的高度    int hl = 0, hr = 0;    while (l != null) {        l = l.left;        hl++;    }    while (r != null) {        r = r.right;        hr++;    }    // 如果左右子树的高度相同，则是一棵满二叉树    if (hl == hr) {        return (int) Math.pow(2, hl) - 1;    }    // 如果左右高度不同，则按照普通二叉树的逻辑计算    return 1 + countNodes(root.left) + countNodes(root.right);}// 复杂度分析动态规划  运筹学的一种最优化方法一般形式 ：求最值  核心问题 ：穷举重叠子问题  暴力穷举效率低下 所以需要备忘录或者DP table来优化穷举过程 避免不必要的计算动态规划具备最优子结构只有列出正确的状态转移方程才能正确的穷举明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义。# 重叠子问题 -&gt; 斐波那契数列int fib(int N) {    if (N &lt; 1)         return 0;    // 备忘录全初始化为0    vector&lt;int&gt; memo(N+1, 0);    // 进行带备忘录的递归    return helper(memo, N);}# 自顶向下int helper(vector&lt;int&gt;&amp; memo, int n) {    // base case    if (n == 1 || n == 2)        return 1;    // 如果已经计算过 直接返回    if (memo[n] != 0) {        return memo[n];    }     // 否则递归计算    memo[n] = helper(memo, n-1) + helper(memo, n-2);    return memo[n];}# 动态规划 自底向上 循环迭代int fib(int N) {    if (N &lt; 1)        return 0;    if (N == 1 || N == 2)         return 1;    vector&lt;int&gt; dp(N+1, 0);    // base case    dp[1] = dp[2] = 1;    for (int i=3; i&lt;=N; i++) {        dp[i] = dp[i-1] + dp[i-2];    }    return dp[N];}# 优化空间复杂度 dp tableint fib(int n) {    if (n &lt; 1)         return 0;    if (n == 1 || n == 2)         return 1;    int prev = 1, curr = 1;    for (int i=3; i&lt;=n; i++) {        int sum = prev + curr;        prev = curr;        curr = sum;    }    return curr;}# 凑零钱问题1. 确定base case 2. 确定状态 问题中会变化的量3. 确定选择4. 明确dp数组的定义# 暴力递归def coinChange(coins: List[int], amout: int):    def dp(n):        # base case        if n == 0: return 0;        if n &lt; 0: return -1;        # 求最小值，所以初始化为正无穷        res = float(&apos;INF&apos;)        for coin in coins:            subproblem = dp(n - coin)            # 子问题无解，跳过            if subproblem == -1:                continue            res = min(res, 1 + subproblem)        return res if res != float(&apos;INF&apos;) else -1    return dp(amount)# 带备忘录的递归def coinChange(coins: List[int], amount: int):    # 备忘录    memo = dict()    def dp(n):        # 查备忘录, 避免重复计算        if n in memo:            return memo[n]        # base case        if n == 0:            return 0        if n &lt; 0:            return -1        res = float(&apos;INF&apos;)        for coin in coins:            subproblem = dp(n - coin)            if subproblem == -1:                continue            res = min(res, 1 + subproblem)        # 记入备忘录        memo[n] = res if res != float(&apos;INF&apos;) else -1        return memo[n]    return dp(amount)# dp数组的迭代解法int coinChange(vector&lt;int&gt;&amp; coins, int amount) {    // 数组大小为 amount + 1，初始值也为 amount + 1    vector&lt;int&gt; dp(amount+1, amount+1);    // base case    dp[0] = 0;    // 外层 for 循环遍历所有状态的所有取值    for (int i=0; i&lt;dp.size(); i++) {        // 内层 for 循环在求所有选择的最小值        for(int coin: coins) {            // 子问题无解，跳过            if (i - coin &lt; 0)                 continue            // 选或不选            dp[i] = min(dp[i], 1 + dp[i-coin]);         }    }    return (dp[amount] == amount+1) ? -1 : dp[amount];}# 最优子结构 子问题之间必须相互独立动态规划 = 最优子结构 + 重叠子问题暴力递归解 -&gt; 优化（备忘录） -&gt; dp数组迭代dp数组    1. 明确dp数组的含义    2. 定义base case    3. 找状态转移方程遍历dp数组1、遍历的过程中，所需的状态必须是已经计算出来的。2、遍历的终点必须是存储结果的那个位置。# 最长公共子序列    1. dp[i][j]的含义是：对于s1[1..i]和s2[1..j]，它们的LCS长度是dp[i][j]    2. base case  索引为0的行或列表示空串    3. 找状态转移方程    # 暴力递归    def longestCommonSubsequence(str1, str2) -&gt; int:        def dp(i, j):            # 空串的base case            if i == -1 or j == -1:                return 0;            if str1[i] == str2[j]:                # 找到一个lcs元素，继续往前找                return dp(i-1, j-1) + 1            else:  # 当前不是lcs元素                # 谁能让lcs最长，就听谁的                return max(dp(i-1, j), dp(i, j-1))        # i和j初始化为最后一个索引        return dp(len(str1)-1, len(str2)-1)    # dp table 自底向上迭代    def longestCommonSubsequence(str1, str2) -&gt; int:        m, n = len(str1), len(str2)        #  构建DP table 和 base case        dp = [[0] * (n+1) for _ in range(m+1)]        # 进行状态转移        for i in range(1, m+1):            for j in range(1, n+1):                if str1[i-1] == str2[j-1]:                    dp[i][j] = 1 + dp[i-1][j-1]                else:                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])        return dp[m][n]# 编辑距离DNA相似度horse -&gt; rosintention -&gt; executionrad -&gt; apples1 -&gt; s2if s1[i] == s2[j]:    skip    i,j同时向前移动else:    3选1        insert        delete        replacedef minDistance(s1, s2) -&gt; int:    # 返回s1[0..i] 和 s2[0..j]的最小编辑距离    def dp(i, j):        # base case是i走完s1, j走完s2, 直接返回另一个字符串剩下的长度        if i == -1: return j+1        if j == -1: return i+1        if s1[i] == s2[j]:            return dp(i-1, j-1) # skip        else:            return min(                dp(i, j-1) + 1,  # 插入                dp(i-1, j) + 1,  # 删除                dp(i-1, j-1) + 1, # 替换                )        # i,j 初始化指向最后一个索引        return dp(len(s1)-1, len(s2)-1)dp[i-1][j-1]存储s1和s2的最小编辑距离int minDistance(String s1, String s2) {    int m = s1.length, n = s2.length();    int[][] dp = new int[m+1][n+1];    // base case    for (int i=1; i&lt;m; i++) {        dp[i][0] = i;    }    for (int j=1; j&lt;n; j++) {        dp[0][j] = j;    }    // 自底向上求解    for (int i=1; i&lt;=m; i++) {        for (int j=1; j&lt;=n; j++) {            if (s1.charAt(i-1) == s2.charAt(j-1))                 dp[i][j] = dp[i-1][j-1];            else                dp[i][j] = min(                    dp[i-1][j] + 1,                    dp[i][j-1] + 1,                    dp[i-1][j-1] + 1                    );        }    }    return dp[m][n];}int min(int a, int b, int c) {    return Math.min(a, Math.min(b, c));}# 数学归纳法最长递增子序列 1维dp[i] 表示以nums[i]这个数结尾的最长递增子序列的长度public int lengthOfLTS(int[] nums) {    int[] dp = new int[nums.length];    // dp数组全都初始化为1    Arrays.fill(dp, 1);    for (int i=1; i&lt;nums.length; i++) {        for (int j=0; j&lt;i; j++) {            if (nums[j] &lt; nums[i])             dp[i] = Math.max(dp[i], dp[j]+1);        }    }    int res = 0;    for (int i=0; i&lt;dp.length; i++) {        res = Math.max(res, dp[i]);    }    return res;}# 最长回文子串String palindrome(String s, int l, int r) {    // 防止索引越界    while(l &gt;=0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] == s[r]) {        // 向两边展开        l--;        r++;    }    return s.substr(l+1, r-l-1);}String longestPalindrome(String s) {    String res;    for (int i=0; i&lt;s.size(); i++) {        // 以s[i]为中心的最长回文子串        String s1 = palindrome(s, i, i);        //     以s[i] 和 s[i+1] 为中心的最长回文子串        String s2 = palindrome(s, i, i+1);        res = res.size() &gt; s1.size()? res : s1;        res = res.size() &gt; s2.size()? res : s2;    }    return res;}# 最长回文子序列 2维dp数组的定义 : 在子串s[i..j]中，最长回文子序列的长度为dp[i][j]要求的是dp[0][n-1]int longestpalindromeSubseq(string s) {    int n = s.size();    // dp 数组全部初始化为0    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n,0));    // base case    for (int i=0; i&lt;n; i++) {        dp[i][i] = 1;    }    // 反着遍历保证正确的状态转移    for (int i=n-2; i&gt;=0; i--) {        for (int j=i+1; j&lt;n; j++) {            // 状态转移方程            if (s[i] == s[j])                dp[i][j] = dp[i+1][j-1] + 2;            else                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);        }    }    // 整个s的最长回文子串长度    return dp[0][n-1];}    </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xcode</title>
      <link href="/2020/12/18/xcode/"/>
      <url>/2020/12/18/xcode/</url>
      
        <content type="html"><![CDATA[<p>xcode 使用相对路径<br><a href="https://blog.csdn.net/u010053344/article/details/51379222" target="_blank" rel="noopener">https://blog.csdn.net/u010053344/article/details/51379222</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpu内核概念</title>
      <link href="/2020/12/10/cpu%E5%86%85%E6%A0%B8%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/12/10/cpu%E5%86%85%E6%A0%B8%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>性能基础之CPU、物理核、逻辑核概念与关系<br><a href="https://cloud.tencent.com/developer/article/1465603" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1465603</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pytorch框架设计</title>
      <link href="/2020/12/07/pytorch%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>/2020/12/07/pytorch%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Intelij IDEA</title>
      <link href="/2020/11/26/Intelij-IDEA/"/>
      <url>/2020/11/26/Intelij-IDEA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TF-Lite 示例应用</title>
      <link href="/2020/11/24/TF-Lite-%E7%A4%BA%E4%BE%8B%E5%BA%94%E7%94%A8/"/>
      <url>/2020/11/24/TF-Lite-%E7%A4%BA%E4%BE%8B%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>目标检测ios示例<br>使用CocoaPods来下载TF Lite 库<br>CocoaPods简介:</p><p>CocoaPods是一个用Ruby写的、负责管理iOS项目中第三方开源库的工具，CocoaPods能让我们集中的、统一管理第三方开源库，为我们节省设置和更新第三方开源库的时间。</p><pre><code>CocoaPods安装参考 https://www.jianshu.com/p/f43b5964f582升级Ruby    ruby -v 查看ruby版本升级Ruby环境，首先需要安装rvm    curl -L get.rvm.io | bash -s stable         报错 Failed to connect to raw.githubusercontent.com port 443: Connection refused error: Error: 7，        解决方法 https://blog.csdn.net/txl910514/article/details/105880125sudo gem update --system  更新gemsudo gem install cocoapodscd lite/examples/object_detection/ios/ pod install在xcode中打开 ObjectDetection.xcworkspace但是得注册Apple Developer 用于开启ios设备的权限</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>存储</title>
      <link href="/2020/11/10/%E5%AD%98%E5%82%A8/"/>
      <url>/2020/11/10/%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<p>参考<br><a href="https://www.cnblogs.com/debruyne/p/9177314.html" target="_blank" rel="noopener">https://www.cnblogs.com/debruyne/p/9177314.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android基础用户界面</title>
      <link href="/2020/10/09/Android%E5%9F%BA%E7%A1%80%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/"/>
      <url>/2020/10/09/Android%E5%9F%BA%E7%A1%80%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux显示乱码问题</title>
      <link href="/2020/09/30/Linux%E6%98%BE%E7%A4%BA%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2020/09/30/Linux%E6%98%BE%E7%A4%BA%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/shiyong1949/article/details/79462077" target="_blank" rel="noopener">https://blog.csdn.net/shiyong1949/article/details/79462077</a></p><p>yum install convmv<br>convmv -f gbk -t utf-8 -r –notest /home/wwwroot </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java教程</title>
      <link href="/2020/09/03/Java%E6%95%99%E7%A8%8B/"/>
      <url>/2020/09/03/Java%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>常用的DOS命令<br>启动 Win + R 输入cmd<br>cmd<br>cd<br>dir<br>cls 清楚屏幕<br>exit退出窗口</p><p>JVM–实现Java语言的跨平台性，起到翻译的作用<br>JRE(Java Runtime Enviroment) 运行程序环境<br>JDK(Java Development Kit)– Java开发工具包</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2020/08/28/%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/08/28/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>十大经典排序算法 动图演示<br><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/7674659.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N皇后</title>
      <link href="/2020/08/25/N%E7%9A%87%E5%90%8E/"/>
      <url>/2020/08/25/N%E7%9A%87%E5%90%8E/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2020/08/24/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2020/08/24/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>负数的二进制表示<br>十进制5在计算机中表示为 int类型占4个字节<br>00000000 00000000 00000000 00000101<br>那么-5在计算机中应该怎么表示呢？</p><p>在计算机中，<em>负数以其正值的补码形式表达</em><br>什么叫补码呢？这得从原码，反码说起。<br>原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。<br>比如 00000000 00000000 00000000 00000101 是 5的 原码。<br>反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。<br>原码 00000000 00000000 00000000 00000101<br>反码 11111111 11111111 11111111 11111010<br>补码 11111111 11111111 11111111 11111011<br>补码： 反码+1称为补码<br>所以， -5在计算机中表达为：<br>11111111 11111111 11111111 11111011<br>转换为16进制： 0xFFFFFFFB</p><p>-1在计算机中如何表示<br>1的原码<br>00000000 00000000 00000000 00000001<br>1的反码<br>11111111 11111111 11111111 11111110<br>补码<br>11111111 11111111 11111111 11111111<br>可见， -1在计算机里用二进制表达就是全1<br>16进制为：0xFFFFFF</p><p>内容来自：<a href="https://www.jianshu.com/p/6c518e7b4690" target="_blank" rel="noopener">https://www.jianshu.com/p/6c518e7b4690</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2020/08/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2020/08/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>class UF {<br>    // 记录连通分量<br>    private int count<br>    // 节点x的父节点是parent[x]<br>    private int[] parent;<br>    // 新增一个数组来记录树的“重量” 为了避免造成树的不平衡<br>    private int[] size;</p><pre><code>/*构造函数， n为图的节点总数*/public UF(int n) {    // 一开始互不相通    this.count = n; // 连通分量的个数        // 父节点指针指向自己    parent = new int[n];    // 最初每棵树只有一个节点    // 重量应该初始化为1    size = new int[n];    for (int i=0; i&lt;n; i++) {        parent[i] = i;        size[i] = 1;  // 初始状态的节点个数为1    }}/* 将p和q连接 */public void union(int p, int q) {    int rootP = find(p);    int rootQ = find(q);    if (rootP == rootQ)         return;    // 将两棵树合并为一颗    // 小树接到大树下面，较平衡    if (size[rootP] &gt; size[rootQ]) {        parent[rootQ] = rootP;        size[rootP] += size[rootQ];    } else {        parent[rootP] = rootQ;        size[rootQ] += rootP;     }    count--; // 两个分量合二为一 }/* 返回某个节点x的根节点 */private int find(int x) {    // 根节点parent[x] == x    while (parent[x] != x) {        // 进行路径压缩        parent[x] = parent[parent[x]];        x = parent[x];    }    return x;}/* 判断p和q是否连通*/public boolean connected(int p, int q) {    int rootP = find(p);    int rootQ = find(q);    return rootP == rootQ;}/* 返回图中有多少个联通分量 */public int count() {    return count;}</code></pre><p>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minimax-Algorithm</title>
      <link href="/2020/08/14/Minimax-Algorithm/"/>
      <url>/2020/08/14/Minimax-Algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="—"><a href="#—" class="headerlink" title="—"></a>—</h1><h1 id="title-Minimax-Algorithm"><a href="#title-Minimax-Algorithm" class="headerlink" title="title: Minimax Algorithm"></a>title: Minimax Algorithm</h1><h1 id="date-2020-08-14-20-03-12"><a href="#date-2020-08-14-20-03-12" class="headerlink" title="date: 2020-08-14 20:03:12"></a>date: 2020-08-14 20:03:12</h1><h1 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h1><h1 id="categories-Algorithm"><a href="#categories-Algorithm" class="headerlink" title="categories: Algorithm"></a>categories: Algorithm</h1><h1 id="—-1"><a href="#—-1" class="headerlink" title="—"></a>—</h1><p><a href="https://segmentfault.com/a/1190000013527949" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013527949</a><br>const maxDepth = 4;<br>let counter = 1;</p><p>const dataTree = [<br>                    [<br>                        [<br>                            [3, 17], [2, 12]<br>                        ],<br>                        [<br>                            [15], [25, 0]<br>                        ]<br>                    ],<br>                    [<br>                        [<br>                            [2, 5], [3]<br>                        ]<br>                        [<br>                            [2, 14]<br>                        ]<br>                    ]<br>                ];</p><p>constructor(data, type, depth) {<br>    this.data = data;<br>    this.type = type; // 区分此节点的种类是max或min<br>    this.depth = depth;<br>}</p><p>function changeType(type) {<br>    return type === ‘max’ ? ‘min’ : ‘max’;<br>}</p><p>score() {<br>    // 到达了最大深度后，此时的data是数组最内层的数字<br>    if (this.depth &gt;= 4) {<br>        return this.data;<br>    }    </p><pre><code>// 对于max节点，返回的是子节点中的最大值if (this.type === &apos;max&apos;) {    let maxScore = -1000;    for (let i=0; i &lt; this.data.length; i++) {        const d = this.data[i];        // 生成新的节点，子节点的type会和父节点不同        const childNode = new Node(d, changeType(this.type), this.depth+1);        // 递归获取其分数        const childScore = childNode.score();        if (childScore &gt; maxScore) {            maxScore = childScore;        }    }    return maxScore;}// 对于min节点，返回的是子节点中的最小值if (this.type === &apos;min&apos;) {    let minScore = 1000;    for (let i=0; i &lt; this.data.length; i++) {        const d = this.data[i];        // 生成新的节点，子节点的type会和父节点不同        const childNode = new Node(d, changeType(this.type), this.depth+1);        // 递归获取其分数        const childScore = childNode.score();        if (childScore &gt; minScore) {            minScore = childScore;        }    }    return minScore;}</code></pre><p>}</p><p>const testNode = new Node(dataTree, ‘max’, 0);<br>console.log(testNode.score());</p><hr><p>Alpha-beta 剪枝算法的实现<br>是minimax的改进</p><p>class Node{<br>    constructor(data, type, depth) {<br>        this.data = data;<br>        this.type = type; // 区分此节点的种类是max或min<br>        this.depth = depth;</p><pre><code>    this.alpha = alpha || -Infinity;    this.beta = beta || Infinity;}score() {}</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AI</title>
      <link href="/2020/08/13/AI/"/>
      <url>/2020/08/13/AI/</url>
      
        <content type="html"><![CDATA[<p>project1数独<br>约束传播和搜索</p><p>project2 Build an AI that play games<br>minimax alpha-beta pruning<br>吃豆人<br>BFS DFS A*<br>最优路径问题</p><p>project3 马尔可夫模型 手语字符转化为对应的英文文本</p><p>Navigation 导航 A*<br>智能体 动态交互<br>棋盘的状态 搜索树 剪枝<br>对抗搜索 Mini-Max</p><p>Monty Hall三门问题<br>switch<br>先验概率 P(A) = P(B) = P(C) = 1/3<br>后验概率 P(B|open_B) = 0<br>贝叶斯定理<br>P(C|open_B) = P(open_B|C) * P(C) / P(open_B)  = 1 * 1/3 / 1/2 = 2/3</p><p>智能的定义是什么？<br>Agent, Enviroment, State<br>智能体：是指会根据给定目标采取行动，最大化其预期效用的事物<br>Perception, Action, Cognition<br>感知： 智能体通过感知环境属性与环境互动<br>行为：输出行为通常会改变环境的状态<br>认知：智能体决定采取什么行动的过程，取决于感知输入，这个过程称为认知<br>我们对AI的大部分讨论都会集中在认知上，特别是推理和决策<br>有限最优性</p><p>Conda与pip相似，不同之处在于可用的软件包集中于数据科学，而pip则用于一般用途。<br><code>conda create -n env_name list of packages</code><br><code>conda create -n data python=3.6 numpy pandas</code><br><code>source activate env_name</code><br><code>conda list</code> 查看安装的packages<br><code>source deactivate</code></p><p>保存和加载环境<br><code>conda env export &gt; enviroment.yaml</code><br>write the exported text to a YAML file</p><p>从保存的环境文件创建行动环境<br><code>conda env create -f enviroment.yaml</code><br>create a new enviroment with the same listed in enviroment.yaml</p><p>移除环境<br><code>conda env remove -n env_name</code></p><p>windows配置Git环境变量<br><a href="https://blog.csdn.net/C_chuxin/article/details/87880332" target="_blank" rel="noopener">https://blog.csdn.net/C_chuxin/article/details/87880332</a></p><hr><p>搜索、逻辑、规划<br>概率、贝叶斯网络<br>Main topics:</p><ol><li>Adversarial Search</li><li>Minimax Algorithm</li><li>Alpha-Beta pruning</li><li>Evaluation Functions</li><li>Isolation Functions</li><li>Multi-player, probabilistic Games</li></ol><p>——————————————————————————————————————<br>路径搜索<br>Definition of A problem<br>Initial State  -&gt; S0     开始的城市<br>Actions(S)     -&gt; {a1, a2, a3…}   可到达的城市的路径<br>Result(S, a)   -&gt; S’   （到达）新的城市<br>GoalTest(S)    -&gt; True|False 判断是否到达目标城市<br>Path Cost（Si -aj-&gt; Si+1 -aj+1-&gt; Si+2）–&gt; cost value(n) where i=0,1… j=1,2…  总的cost<br>Step Cost (S, a, S’) –&gt; n  单步cost</p><p>Frontier 已访问的边界<br>Unexplored 未访问<br>Explored  已访问</p><p>Tree Search<br>function Tree.Search(problem):<br>    frontier = {[initial]}<br>    loop:<br>        if frontier is empty:<br>            return FAIL<br>        path = remove.choice(frontier)<br>        s = path.end<br>        if s is a goal:<br>            return path<br>        for a in actions:<br>            add[path + a &gt; Result(s, a)] to frontier</p><p>Breadth First Search<br>shortest path first</p><p>Graph Search<br>function Graph.Search(problem):<br>    frontier = {[initial]};<br>    explored = {} // 记录已访问的节点<br>    loop:<br>        if frontier is empty:<br>            return FAIL<br>        path = remove.choice(frontier)<br>        s = path.end; add to explored<br>        if s is a goal:<br>            return path<br>        for a in actions:<br>            add [path + a -&gt; Result(s, a)] to frontier<br>            unless Result(s, a) in frontier or explored // 避免重复</p><p>A*搜索算法</p>]]></content>
      
      
      <categories>
          
          <category> Udacity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML &amp; CSS</title>
      <link href="/2020/08/11/HTML-CSS/"/>
      <url>/2020/08/11/HTML-CSS/</url>
      
        <content type="html"><![CDATA[<p>树形结构<br>h1元素 <h1>This is a heading.</h1></p><p>This is a paragraph.</p>>标签 <h1> <p> <span> <image><p>This is a paragraph.</p><span>span1</span> 一行<span>span2</span><p>命令行启动sublime<br>MAC 打开终端输入下面的命令并回车即可<br>ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl</p><p>添加完系统变量之后，接下来你就可以在命令行里面利用subl命令直接使用Sublime Text了：<br>subl file : 使用Sublime Text打开file文件<br>subl folder : 使用Sublime Text打开folder文件夹<br>subl . : 使用Sublime Text当前文件夹</p><p>Chrome<br>cmd + o 打开文件<br>Cmd + R 刷新文件</p><p><tag>Content</tag><br>递归嵌套</p><div>    <h1>Article Title</h1>    <p>Paragraph of text.</p> </div><p>前往 MDN HTML 元素参考 中文网站 ，寻找你要使用的元素。<br>MDN (Mozilla Developer Network)<br>cmd + f 寻找关键字<br><b> bold 粗体 </b><br><em> emphasis 着重 </em></p><p>HTML文档模版<br><!DOCTYPE html> 描述HTML的类型</p><html>    <head>        Meta information goes here!        描述有关站点的元信息(例如标题)，         并提供网页正确渲染和交互，所需的脚本和样式表链接    <meta name="generator" content="Hexo 4.2.0"></head>    <body>        Content goes here!        描述用户将看到的网页上的实际内容    </body></html>   <!DOCTYPE html><html>    <head>        <meta charset="utf-8">        <title>This is a title</title>    </head>    <body>        <h1>Hello!</h1>    </body></html><p>按钮标签<br><button>一个按钮！</button></p><p>标题标签<br><!DOCTYPE html></p><html>    <head></head>    <body>        <p>            <h1>HomePage</h1>            <h2>Welcome to my website</h2>            <h3>about me</h3>            <h4>more</h4>            <span>SpaceX launched the Falcom Havey</span>        </p>    </body></html><p>列表标签<br><!DOCTYPE html></p><html>    <head>    </head>       <body>        <p>            <ul>                <li>HTML</li>                <li>CSS</li>                <li>JavaScript</li>            </ul>        </p>    </body></html>   <p>HTML树<br><!DOCTYPE html></p><html>    <head></head>       <body>        <h1>树形结构</h1>        <div>            <p>你可以使用树形结构整理HTML文件，使它们更具有条理</p>            <p>这不仅有利于可读性，还与CSS、JavaScript的风格和编程形式保持了一致</p>        </div>     </body></html><p>使用链接元素创建超链接<br><a href="www.google.com">谷歌</a><br>href代表“引用” </p><p>使用img元素创建图像 图像不需要结束标签<br><img src="http://somewensite.com/image.jpg" alt="short description"></p><!DOCTYPE html><html lang="en">    <head></head>    <body>        <p>            这里是一大段有关 Udacity 的文字。很酷！接下来是图像！        </p>        <img src="http://udacity.github.io/fend/images/udacity.png", alt="Udacity Logo">    </body></html><p>路径指南<br>绝对路径 ：世界上任何人都可以使用地址 1600 Pennsylvania Ave NW, Washington DC, USA 20006 找到美国白宫。街道地址是指向某地点的绝对路径。<br>相对路径 ：但如果你就在艾森豪行政大楼， 那么你还可以使用“隔壁大楼”来查找白宫。 “隔壁大楼”需要依赖当前位置，因此是一个相对路径。</p><p>本地文件<br>外部文件</p><p>本地路径<br>外部路径<br>相对路径</p><p>负责为你提供网站文件的计算机称为 <em>服务器</em><br>服务器具有任何人都可以访问的外部路径，这也正是 Web 的工作原理。<br>不同的网站只不过是不同的文件集合。每个网站其实都只是具有外部地址的服务器（或多个服务器）， 我们称外部地址为 URL</p><p>图片描述<br><!DOCTYPE html></p><html lang="en">    <head></head>    <body>        <figure>            <img src="redwoods_state_park.jpg" alt="redwoods">            <figcaption> readwoods_state_park.jpg</figcaption>        </figure>        <p> 斯托特纪念森林，杰迪戴亚·史密斯红木州立公园，2011 年，由 Chmee2 拍摄。GFDL 或 CC BY-SA 3.0，来自 Wikimedia Commons -             <a href="https://commons.wikimedia.org/wiki/File%3AStout_Memorial_Grove_in_Jedediah_Smith_Redwoods_State_Park_in_2011_(22).JPG" target="_blank" rel="noopener">source</a>        </p>    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>]]></content>
      
      
      <categories>
          
          <category> Udacity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html, css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉</title>
      <link href="/2020/08/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
      <url>/2020/08/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Udacity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度碎片</title>
      <link href="/2020/08/08/%E6%B7%B1%E5%BA%A6%E7%A2%8E%E7%89%87/"/>
      <url>/2020/08/08/%E6%B7%B1%E5%BA%A6%E7%A2%8E%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>np.squeeze() 去除单维度的条目</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UdacityDL</title>
      <link href="/2020/07/29/UdacityDL/"/>
      <url>/2020/07/29/UdacityDL/</url>
      
        <content type="html"><![CDATA[<h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p>什么是Anaconda ？<br>Anaconda实际上是conda，Python和150多个科学软件包及其依赖项附带的软件发行版。应用程序conda是程序包和环境管理器。</p><p>安装Anaconda<br>Anaconda is available for Windows, Mac OS X, and Linux. You can find the installers and installation instructions at <a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">https://www.anaconda.com/download/</a>.</p><p>安装后，您将自动进入默认的conda环境，并安装了所有软件包，您可以通过在终端中输入<code>conda list</code>来检查自己的安装。</p><p>包管理<br>conda install numpy</p><p>创建环境<br>conda create -n env_name list of packages    (-n for name)<br>conda create -n my_env numpy<br>指定python版本<br>conda create -n py38 python=3.8</p><p>进入环境<br>source activate my_env  (OSX/Linux)<br>activate my_env  (Windows)</p><p>conda create -n data py36 python=3.6 numpy pandas</p><p>保存和加载环境<br><code>conda env export &gt; enviroment.yaml</code>  保存环境到yaml文件<br>conda env export<br><code>conda env create -f environment.yaml</code> 从yaml文件创建环境</p><p>环境列表<br>conda env list</p><p>移除环境<br>conda env remove -n env_name</p><h3 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h3>]]></content>
      
      
      <categories>
          
          <category> Udacity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>广度优先搜索</title>
      <link href="/2020/07/28/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
      <url>/2020/07/28/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p> BFS代码模版<br> def BFS(graph, start, end):<br>     queue = []<br>     queue.append([start])<br>     visited.add(start)</p><pre><code>while queue:    node = queue.pop()    visited.add(node)    process(node)    nodes = generate_related_nodes(node)    queue.push(nodes)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深度优先搜索</title>
      <link href="/2020/07/28/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
      <url>/2020/07/28/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>示例代码<br>python<br>class TreeNode:<br>    def <strong>init</strong>(self, val):<br>        self.val = val;<br>        self.left, self.right = None, None</p><p>C++<br>Struct TreeNode {<br>    int val;<br>    TreeNode * left;<br>    TreeNode * right;<br>    TreeNode(int x) : val(x),left(NULL),right(NULL) {}<br>}</p><p>Java<br>public class TreeNode {<br>    public int val;<br>    public TreeNode left, right;</p><pre><code>public TreeNode(int val) {    this.val = val;    this.left = null;    this.right = null;}</code></pre><p>}</p><p>二叉树dsf 示例代码<br>def dsf(node):<br>    if node in visited:<br>        # already visited<br>        return</p><pre><code>visited.add(node)# process current node# ... # logic heredfs(node.left)dfs(node.right)</code></pre><p>多叉树dsf 示例代码<br>visited = set()<br>def dfs(node, visited):<br>    # terminator<br>    if node in visited:<br>        # already visited<br>        return </p><pre><code>visited.add(node);# process current node here# 遍历所有子节点for next_node in node.children:    if not next_node in visited:        dfs(next_node, visited)</code></pre><p>DFS非递归写法<br>def DFS(self, tree):<br>    if tree.root is None:<br>        return []</p><pre><code>visited, stack = [], [tree.root]while stack:    node = stack.pop()    visited.add(node)    process(node)    nodes = generate_related_nodes(node)    stack.push(nodes)# other processing work</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>递归代码模版</title>
      <link href="/2020/07/23/%E9%80%92%E5%BD%92%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/"/>
      <url>/2020/07/23/%E9%80%92%E5%BD%92%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># python 递归模版</span><br><span class="line">def recursion(level, param1, param2, ...):</span><br><span class="line"># recursion terminator</span><br><span class="line">if level &gt; MAX_LEVEL:</span><br><span class="line">process_result</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line"># process logic in current level</span><br><span class="line">process(level, data...)</span><br><span class="line"></span><br><span class="line"># drill down</span><br><span class="line">self.recursion(level+1, p1, ...)</span><br><span class="line"></span><br><span class="line"># reverse the current level status if needed</span><br></pre></td></tr></table></figure><p>// Java递归模版<br>public class recursionTemplate {<br>    public void recur(int level, int param) {</p><pre><code>    // terminator    if (level &gt; MAX_LEVEL) {        // process result        return;    }    // process current logic    process(level, param);    // drill down    recur(level: level + 1, newParam);    // restore current status}</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分治代码模版</title>
      <link href="/2020/07/23/%E5%88%86%E6%B2%BB%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/"/>
      <url>/2020/07/23/%E5%88%86%E6%B2%BB%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>def divede_conquer(problem, param1, param2, …):<br>    # recursion terminator<br>    if problem is None:<br>        print_result<br>        return</p><pre><code># prepare datadata = prepare_data(problem)subproblems = split_problem(problem, data)# conquer subproblemssubresult1 = self.divede_conquer(subproblems[0], p1, ...)subresult2 = self.divede_conquer(subproblems[1], p1, ...)subresult3 = self.divede_conquer(subproblems[2], p1, ...)...# process and generate the final resultresult = process_result(subresult1, subresult2, subresult3, ...)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高效能人士的七个习惯</title>
      <link href="/2020/07/21/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
      <url>/2020/07/21/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/</url>
      
        <content type="html"><![CDATA[<p>第一部分 思维方式与原则<br>    第一章 由内而外的造就自己<br>        付诸行动</p><pre><code>    Q1:你是否曾做出推测时发现自己的判断过于匆忙？请对这种经历加以描述。    在青岛的时候，没有很好地去体谅对方，对你一会不热情，你就以为人家不爱你，冲动地做出了一些傻事，    Q2:你当时做出的推测是什么？    因为是最后一晚在一起，为什么要抗拒我，这样的观点是错误的，两个人在一起可以做很多其他的有意义的事情    Q3:想一下你做过的其他推测。本周你将对其中某一项采取什么行动？    （一）检验你的思维方式    你曾经到过其他国家，或本国的其他地区吗？你觉得哪些事情是陌生的奇怪的？    最近的一次是青岛，当地人    人们的行为是否如你预期？你对他们的行为有何看法？    回想你的旅游经历，你认为当地人对你的看法如何？你是否认为他们对你的看法与你对他们的看法可能很类似？    如果你有机会在旅途中认识当地人，你对他们的看法或推测会有什么改变？    （二）转换你的思维方式    回想一下通往你的工作场所或你家的不同路径。是否有些路径比其他的更复杂？是否有时其中一条比其他的更方便？为什么方便，为什么不方便    你是否发现过一条你以前不知道的新路径？走不同的路径的新鲜感如何？    现在想一下你与他人打交道的方式。与他们打交道是否有好几种方式？你有可能尝试哪些新的方式？    （三）影响你生活的五个原则    请列出影响你的日常生活的五个原则。它们以怎样的方式影响你？它们是以积极还是消极的方式影响你的生活？    1.    2.    3.    4.    5.第二章 七个行动概论    付诸行动</code></pre><p>第二部分 个人领域的成功：从依赖到独立<br>    第三章 习惯一： 积极主动——个人愿景的原则<br>        付诸行动</p><pre><code>第四章 习惯二： 以始为终——自我领导的原则    付诸行动第五章 习惯三： 要事第一——自我管理的原则    付诸行动</code></pre><p>第三部分 公众领域的成功：从独立到互赖<br>    第六章 人际关系的本质<br>        付诸行动</p><pre><code>第七章 习惯四：双赢思维——人际领导的原则    付诸行动第八章 习惯五：知彼解己——移情沟通的原则    付诸行动第九章 习惯六：统合综效——创造性合作的原则    付诸行动</code></pre><p>第四部分 自我提升和完善<br>    第十章 习惯七：不断更新——平衡点自我提升法则<br>        付诸行动</p><pre><code>第十一章 再论由内而外造就自己    付诸行动</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门</title>
      <link href="/2020/07/21/Java%E5%85%A5%E9%97%A8/"/>
      <url>/2020/07/21/Java%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>Java Dvelopment Kit (JDK)<br>    1. Java Runtime Enviroment (JRE)<br>        Includes the code behind all the variable types and built-in functions (ex. the println() function)<br>        包含所有变量类型和Java内置函数涉及的代码 比如println()函数</p><pre><code>    which allows Java code to run on any platform!    It also includes a Java Virtual Machine (JVM).    Runtime Enviroment 还含有一个Java虚拟机 该虚拟机可以从网上下载 可允许Java代码在任何计算机上运行 无论是Windows、Mac还是其它操作系统都可     很多电脑本身就装有Runtime Enviroment 因为计算机需要这个工具来运行网页里的Java应用程序    但是要开发我们自己的程序和Java应用，我们需要第二个工具 也就是Java编译器2. a Java compiler (javac)    A compiler is a special type of program that translates programing language code into code that a computer can excute    Program code --in--&gt; Compiler ---out--&gt; Translated code    Java Code -&gt; Compiler(javac) -&gt; Bytecode -&gt; Java Virtual Machine -&gt; Machine Code </code></pre><p>在编辑器中编写Java代码<br>    subl HelloWorld.java<br>    // 保存文件时 文件名应与类名相同<br>    public class HelloWorld {<br>        // class 在Java中是用来存放函数和代码并关联程序的<br>        public static void main(String[] args) {<br>            System.out.println(“Hello world!”);<br>        }<br>    }</p><p>在terminal中运行Java代码的流程<br>    1. javac 代码文件名.java<br>        对代码进行编译 生成class文件<br>    2. java 文件名<br>        执行java程序<br>    在编辑器修改代码后 需要重新编译</p><p>Java集成开发环境 Intellij<br>Debug<br>    断点<br>    step over<br>    resume<br>    step into<br>    step out</p><p>自动生成注释<br>/ + a + tab<br><a href="https://blog.csdn.net/qq_34581118/article/details/78409782" target="_blank" rel="noopener">https://blog.csdn.net/qq_34581118/article/details/78409782</a></p><p>ctrl + j 查看方法文档</p><p>static 表示它不需要对象就能运行，因此计算机在创建任何对象之前，会从该方法开始<br>构造方法：是特殊的方法，负责为该类创建和初始化对象<br>    1. 构造方法没有任何返回类型<br>    2. 构造方法的名称和类本身的名称一样</p><p>默认构造函数<br>参数化构造函数<br>class Game{<br>    int score;</p><pre><code>// Default constructorGame() {    score = 0;}// Constructor by starting score valueGame(int startingScore) {    score = startingScore;}</code></pre><p>}</p><p>// 访问构造方法<br>new关键字 要创建特定类的对象，你需要使用 new 关键字，后面是要使用的构造方法<br>Game tetris = new Game(); // 调用默认构造函数<br>Game darts = new Game(100); // 调用带参构造函数</p><p>始终尝试将所有字段声明为 private<br>创建一个将这些 private 字段当做输入的构造函数<br>创建一个设置每个 private 字段的 public 方法，这样你就知道何时更改了字段。这些方法叫做 setter<br>创建一个返回每个 private 字段的 public 方法，这样你就能够读取该字段，而不会不小心更改了它。这些方法叫做 getter</p><p>将所有类设为 public<br>将所有字段设为 private<br>将所有当做操作的方法设为 public<br>将所有当做辅助方法的方法设为 private</p><p>System.out.println(“Enter your address: “);<br>// 创建scanner对象 Scanner 允许程序读取来自特定输入的任何数据类型<br>// 你可以使用它来读取 String、整数或整个行。<br>Scanner scanner = new Scanner(System.in);<br>// 在该 scanner 对象中调用方法 nextLine() 将返回一个 String，其中包含用户在按下”enter”前输入的所有内容。<br>String address = scanner.nextLine();<br>System.out.println(“You live in “ + address);</p><p>简而言之，在大多数情况下，你会希望变量和方法属于某个对象，而不是整个类，因此在大多数情况下，你不需要声明为 Static。但是，如果你要创建一个提供某种功能的类，而不是拥有自己的状态，那么就非常适合将其大部分方法和字段声明为 Static。</p><p>例如，还记得我们用来生成随机数字的 Math 类吗？该 Math 类是具有 random() 等大量 static 方法的类。因为没必要创建一个对象，叫做 math1，再创建一个对象，叫做 math2，所有 Math 都一样，因此我们可以直接使用该类本身来调用其方法，因此这时候就适合使用 static。</p><p>Static 属于类</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极客大学作业提交流程</title>
      <link href="/2020/07/19/%E6%9E%81%E5%AE%A2%E5%A4%A7%E5%AD%A6%E4%BD%9C%E4%B8%9A%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/07/19/%E6%9E%81%E5%AE%A2%E5%A4%A7%E5%AD%A6%E4%BD%9C%E4%B8%9A%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><figcaption><span>add .</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;week0X assignment&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>将对应的链接复制到原始仓库的issue</p><p>#学号:G20200343090088<br>#姓名:张文胜<br>#班级:12期2班<br>#语言:java<br>#作业&amp;总结链接: <a href="https://github.com/VincentCheungKokomo/algorithm012/tree/master/Week_02" target="_blank" rel="noopener">https://github.com/VincentCheungKokomo/algorithm012/tree/master/Week_02</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刻意练习</title>
      <link href="/2020/07/08/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0/"/>
      <url>/2020/07/08/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>刻意练习<br>    ——从新手到大师<br>我们认为杰出的人都是因为天赋，而那些“天才”其实是来自正确的刻意训练</p><p>天才的真相<br>    a. 莫扎特：音乐家父亲的刻意练习<br>    b. 帕格尼尼： 断弦演奏来自事前的练习和策划<br>    c. 训练比智商更重要<br>有目的的练习<br>    a. 定义明确的具体的目标<br>    b. 专注、反馈、走出舒适区<br>    c. 遇到瓶颈：做不同的事；强化动机</p><p>大脑的适应能力<br>    a. 通过适应性训练打造你的“最强大脑”<br>    b. 让大脑步出舒适区： 合理挑战<br>    c. 练习改变大脑结构</p><p>心理表征<br>    a. 心理表征： 思考的心理结构或是下意识<br>    b. 刻意练习能够创建心理表征</p><p>黄金标准<br>    a. 最杰出的人，训练时间最长<br>    b. 运用刻意练习的原则<br>        * 尽可能地运用刻意练习提升技能<br>        * 确定行业的标杆人物及与他人的差别<br>        * 找到优秀导师<br>    c. 1万小时法则：刻板，混淆概念</p><p>在工作中运用刻意练习<br>    a. 拒绝错误思想：我做不到；熟能生巧； 刻苦就够<br>    b. 干中学，传授技能而非知识</p><p>在生活中运用刻意练习原则<br>    a. 找到好导师<br>    b. 投入、专注<br>    c. 3F方法：Focus; Feedback; Fix it</p><p>成为杰出人物的四个阶段<br>    1.产生兴趣<br>    2.变得认真<br>    3.全力投入<br>    4.开拓创新</p>]]></content>
      
      
      <categories>
          
          <category> Books </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编码技巧</title>
      <link href="/2020/07/07/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/07/07/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>快捷键<br><code>fn + delete</code> 删除光标右侧<br><code>cmd+ left/right</code> 行头行尾<br><code>option + left/right</code> 光标按单词切分<br><code>option + delete</code> 删除单词<br><code>shift + command + right</code> 选中整行（光标在行头时）<br>IDE<br>Tab<br>commnad + e<br>Top tips for <IDE-name></p><p>自顶向下的编程方式<br>《clean code》</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《我为何而生》</title>
      <link href="/2020/06/22/%E3%80%8A%E6%88%91%E4%B8%BA%E4%BD%95%E8%80%8C%E7%94%9F%E3%80%8B/"/>
      <url>/2020/06/22/%E3%80%8A%E6%88%91%E4%B8%BA%E4%BD%95%E8%80%8C%E7%94%9F%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>《我为何而生》<br>罗素</p><p>有三种情感，单纯而强烈，支配着我的一生：对爱情的渴望，对知识的追求，以及对人类苦难不可遏制的同情。这些感情如阵阵巨风，挟卷着我在漂泊不定的路途中东飘西荡，飞越苦闷的汪洋大海，直抵绝望的边缘。</p><p>我之所以追寻爱情，首先，爱情使人心醉神迷，如此美妙的感觉，以致使我时常为了体验几小时爱的喜悦，而宁愿献出生命中其它一切；其次，爱情可以解除孤独，身历那种可怕孤寂的人的战栗意识，会穿过世界的边缘，直望入冰冷死寂的无底深渊；最后，置身于爱的结合，我在一个神秘缩影中看到了圣贤与诗人们所预想的天堂。这正是我所追寻的，尽管它对于人类的生活或许太过美好，却是我的最终发现。</p><p>我也以同样的热情追求知识。我渴望理解人类的心灵，渴望知道星辰为何闪耀，我还试图领略毕达哥拉斯关于哪些数字在变迁之上保持着永恒的智慧。在这一方面，我取得了一点成果，但并不算多。</p><p>爱情与知识，尽其可能，引领着我通往天堂；然而怜悯总是把我带回现实。那些痛苦的呼唤在我内心深处回响。饥饿中的孩子，被压迫和折磨的人们，给子女造成重担的无助老人，以及孤独、贫穷和痛苦的整个世界，都是对人类理想生活的嘲讽。我渴望能减少这些不幸，但无能为力，这也是我的痛苦。</p><p>这就是我的一生。我发现人生是值得的；而且如果能够再有一次这样的机会，我会欣然接受。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode</title>
      <link href="/2020/06/10/%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/06/10/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>// 单链表节点的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    ListNode(int x) &#123;</span><br><span class="line">        val &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h2><h3 id="递归反转链表的一部分"><a href="#递归反转链表的一部分" class="headerlink" title="递归反转链表的一部分"></a>递归反转链表的一部分</h3><h4 id="1-递归反转整个链表"><a href="#1-递归反转整个链表" class="headerlink" title="1. 递归反转整个链表"></a>1. 递归反转整个链表</h4><p>明确递归函数的定义： 输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverse(ListNode head) &#123;</span><br><span class="line">    if (head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode last &#x3D; reverse(head.next);</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line">    head.next &#x3D; null;</span><br><span class="line">    return last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-反转链表前N个节点"><a href="#2-反转链表前N个节点" class="headerlink" title="2.  反转链表前N个节点"></a>2.  反转链表前N个节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将链表的前 n 个节点反转（n &lt;&#x3D; 链表长度）</span><br><span class="line">ListNode successor &#x3D; null; &#x2F;&#x2F; 后继节点</span><br><span class="line">&#x2F;&#x2F; 反转以head为起点的n个节点， 返回新的头节点</span><br><span class="line">ListNode reverseN(ListNode head, int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 记录n+1个节点</span><br><span class="line">        successor &#x3D; head.next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 以head.next为起点， 需要反转前n-1个节点</span><br><span class="line">    ListNode last &#x3D; reverseN(head.next, n-1);</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line">    &#x2F;&#x2F; 让反转后的head节点和后面的节点连起来</span><br><span class="line">    head.next &#x3D; successor;</span><br><span class="line">    return last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-反转链表的一部分"><a href="#3-反转链表的一部分" class="headerlink" title="3. 反转链表的一部分"></a>3. 反转链表的一部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverseBetween(ListNode head, int m, int n) &#123;</span><br><span class="line">    &#x2F;&#x2F; base case</span><br><span class="line">    if (m &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 相当于反转前 n 个元素</span><br><span class="line">        return reverseN(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 前进到反转的起点触发 base case</span><br><span class="line">    head.next &#x3D; reverseBetween(head.next, m-1, n-1);</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="25-k个一组反转链表"><a href="#25-k个一组反转链表" class="headerlink" title="25.k个一组反转链表"></a>25.k个一组反转链表</h2><p>// 反转以 a 为头结点的链表<br>ListNode reverse(ListNode a) {<br>    ListNode pre, cur, nxt;<br>    pre = null; cur = a; nxt = a;<br>    while (cur != null) {<br>        nxt = cur.next;<br>        // 逐个节点反转<br>        cur.next = pre;<br>        // 更新指针位置<br>        pre = cur; // 最后的值为最后的节点<br>        cur = nxt; // 最后的值为NULL<br>    }<br>    // 返回反转后的头节点<br>    return pre;<br>}</p><p>/** 反转区间 [a, b) 的元素，注意是左闭右开 */<br>ListNode reverse(ListNode a, ListNode b) {<br>    ListNode pre, cur, nxt;<br>    pre = null; cur = a, nxt = a;<br>    while (cur != b) {<br>        nxt = cur.next;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = nxt;<br>    }<br>    return pre;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br></pre></td></tr></table></figure><p>ListNode reverseKGroup(ListNode head, int k) {<br>    if (head == null) return null;<br>    // 区间 [a, b) 包含 k 个待反转元素<br>    ListNode a, b;<br>    a = b = head;<br>    for (int i = 0 ; i &lt; k ; i++) {<br>        // 不足k个， 不需要反转， base case<br>        if (b == null)<br>            return head;<br>        b = b.next;<br>    }<br>    // 反转前k个元素<br>    ListNode newHead = reverse(a, b);<br>    // 递归反转后续链表并连接起来<br>    a.next = reverseKGroup(b, k);<br>    return newHead;<br>}</p><h2 id=""><a href="#" class="headerlink" title="```"></a>```</h2><h2 id="如何判断回文链表"><a href="#如何判断回文链表" class="headerlink" title="如何判断回文链表"></a>如何判断回文链表</h2>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《幸福课》</title>
      <link href="/2020/06/02/%E3%80%8A%E5%B9%B8%E7%A6%8F%E8%AF%BE%E3%80%8B/"/>
      <url>/2020/06/02/%E3%80%8A%E5%B9%B8%E7%A6%8F%E8%AF%BE%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>19 如何让爱情天长地久</p><ol><li><p>working hard 爱情需要努力耕耘<br>什么是幸福的relationship<br>不能有固定思维 威胁主观意识 finding mindset(fixed)<br>可塑性思维 培养感情 与努力有关 malleable mindset - cultivating mindset(effort)<br>现实中没有完美的爱情<br>找一个对的人的确很重要，然而对这段感情的经营则尤为重要<br>经营感情 working together, being together, spending time together, dedicating one another<br>there are conflicts in a relationship<br>解决矛盾的关键在于 拥有共同的目标<br>主动型的爱 自我认知理论 社交惯例（共进晚餐等）</p></li><li><p>将想要被认可的想法转变为想要被了解<br>be validated 被认可- be known 被了解<br>to be known rather than to be validated 被了解而不只是被认可<br>主动去了解我们的伴侣 最喜欢的酒 最喜欢的花 喜欢如何被碰触 了解他们的恐惧与欲望 什么时候应该给他们留下个人空间<br>什么时候应该与他们谈心 什么时候应该触摸他们 而这些都是需要时间的 life-long process<br>sharing the secret 当分享的时候 将为感情关系带来长期积极的效果<br>亲密时让对方真正了解你 包括那些你或你的伴侣不喜欢的事<br>感情关系的基础是被了解 做真实的自己 认同自己 认同彼此 growing together<br>坦露心声让我们更容易得到伴侣真诚的爱意。为什么呢？因为只有真诚才能够获得别人的信任，坦诚的人更容易被接纳。坦诚相待也能够让一段关系更持久，所以尽自己所能去了解自己的真实想法，并了解你的另一半吧。</p></li><li><p>允许争执的存在<br>冲突是感情中不可避免也是至关重要的组成<br>如果没有冲突 很可能意味着我们正在抑制一些东西 情感 分歧<br>也就是说我们没有互相理解 需要敞开胸怀与人分享<br>幸福推进剂 在一起做有意义有趣的事情<br>Love is in the details, it’s about knowing about the little things and the big things, it is about sharing and being known<br>细节之处见真爱 在于全面了解 在于分享 和被了解<br>抚摸 相视 共进晚餐 拥抱<br>表现出兴趣 创造爱的交流 理解对方<br>抚摸 微笑 送花<br>赞美对方 欣赏促进欣赏<br>不懂得欣赏 不会去赞美 美好的事物也会贬值<br>不要等到别人要求你去赞美 主动点 尽管是免费的<br>从总的趋势来看却又是无价的 赞美者和被赞美者都受益匪浅<br>“making” love 要拥有长久的关系 生理方面是十分重要的<br>交流很重要<br>更加关注彼此 冷静下来 理解对方 心有灵犀<br>在处理争执时如何保持理性的认知<br>对事不对人<br>己所不欲 勿施于人<br>人所不欲 勿施于己<br>感情关系的关键是培养真挚的意义深远的友情</p></li><li><p>积极观念<br>创造优点 而非单纯的发掘优点<br>benifit-creating rather than benifit-finding<br>欣赏伴侣的自律而不将其视为固执<br>欣赏伴侣的幽默感而不将其视为轻浮<br>积极幻觉<br>爱情不仅能感知潜能 还能发挥我们的潜能<br>《尽善尽美》<br>You make me want to be a better man</p></li></ol><p>21 爱情与自尊<br>在朋友身上 我寻求的不是妥协让步 不是盲目同意我的观点的人<br>我所寻找的是完美的敌人 会挑战我 会敦促我 会帮助我寻求真理的人</p><p>提问的重要性<br>questions begin a quest 提问是探求的开端<br>可以发现我们之前忽略的东西<br>提出积极的问题<br>    我的伴侣有什么是值得我感激的？<br>    我们的关系有何美妙之处，有什么进行的很顺利，<br>    最初我们怎么会走到一起的，我爱ta哪一点，有什么好的方面</p><p>我们一直在追求真相 但是当真相来敲我们门的时候 我们却说走开 我在找真相呢</p><p>主动有建设性（active construction）的回应<br>win-win<br>认同 重视对方 与对方融为一体 真诚的回应<br>螺旋上升 构建积极的动力<br>当说到好的关系 健康的关系时 是没有捷径的<br>如果你想要成功就要努力 就像人生中其它每一个方面一样<br>没有捷径 但那并不意味着 这种努力不能是令人享受的 不能是令人愉快并充满意义的<br>而当这种努力变得令人愉快并充满意义时 久而久之 它就会带来更幸福的关系 更幸福的个人<br>带来一个双赢的共存<br>存在有牺牲并且是健康的牺牲 但那并不是一种根本上基于责任感<br>或者为了他人否定自我的关系<br>我们越是独立 就越是相互依存</p><p>自尊 关于我对自己的态度<br>definition：这是在有能力迎接生活的基本挑战 并感到幸福的人生经历中形成的个性<br>为什么自尊很重要？<br>在我们所做出的所有评判中 没有哪个比我们对自己的评判更重要<br>一个人可能犯的最大的罪恶是瞧不起自己<br>高自尊带来的好处<br>    心理健康 更坚韧 更能应对困境<br>    提升情感关系<br>    自我概念就是自我命运 信念是自我实现的预言<br>    如果我认为自己有价值 相信自我 相信自己有能力 我将更有可能成功<br>        成功的两个因素<br>        1. 乐于发问 乐于学习<br>        2. 相信自己</p><pre><code>高情商 自省智商和人际交往智商幸福 相关比0.6</code></pre><p>低自尊心与焦虑相关<br>每个人都会焦虑 就像万有引力是一种物理本质 焦虑也是一种人性的本质</p><p>自尊： 意识的免疫系统 更坚韧的心理状态<br>当我们有高自尊时 我们将有更强的心理适应力<br>强壮的免疫系统不代表不生病 我们会生病 但较少生病 并恢复的比较快<br>少生病 健康才是主旋律<br>追求幸福 而不是一直逃避不幸福</p><p>潜在的因素决定心理障碍或疾病 - 自尊帮助我们理解各种情绪和行为的问题 帮助我们治疗大部分情绪和行为问题<br>不止应用于个人层面还应用于社会层面 社会疫苗</p><p>傲慢自恋不等于自尊</p><p>自尊的本质：<br>自尊不是通过空虚的心理强化获得的<br>区别于伪自尊 心理健康是一种与现实密切相关的状态<br>自尊是基于现实的 基于实际表现的 基于实际成功和实际练习的 是辛勤劳动的成果</p><p>成功的秘密：乐观 相信自己 对所做的事充满激情 最后是勤劳的工作<br>六个练习有助于培养自尊心<br>    正直 言行一致 通过行动与自己交流<br>    自我意识 “我的话很重要 我很重要” 了解自己<br>    有目标 有发自内心的追求 为人生的目标和感召生活<br>    承担责任 要想改变你的人生只有靠你自己（没有人会来）<br>    自我接受的练习 Permission to be human on a daily basis 允许自己做一个普通人<br>    自信的练习 在应该说不的时候说不 在应该说是的时候说是 坚持我们的信仰<br>这些是逐渐培养自尊的练习 同时也是自尊的产物 是一个潜在的自我强化循环</p><p>自尊悖论 成功和低自尊联系在一起<br>自尊不是来源于成功 也不是来源于社会地位或金钱</p><p>自尊的三层渐进式过程<br>           自我价值                  能力<br>1 依赖性自尊 来自他人的赞扬 认同所产生的自尊 不断在寻求自我的肯定 恐惧他人的批评 易被他人左右<br>和其他人比较 每个人都有某种程度的依赖性自尊（人性的本质）<br>2 独立性自尊 由内而发的自尊 根据自己的标准自我评估<br>不与他人比较，而是与自己比较 寻求他人的批判 不断寻求善意的敌人 那些人给ta出难题 在其探索真理的道路上助其一臂之力 因为他们想进步 他们的根本动力是他们自己的兴趣所在<br>3 绝对自尊 简单而自然地存在着的状态 不取决于他人的评价 甚至不由我自己的评价决定 足够自信 不接受任何评价的影响 并不是指漠视或者排斥他人的情感<br>当我们置身事外时，我们与他人的关系更加和谐友好 并且我们也更在乎他们 我们更同情 也更怜悯他人<br>我们尽量置身事外 我们不会因为与他人比较而感到羡慕 骄傲或自卑<br>相互决定 有时需要花上终生的时间才能培养足够强的绝对自尊 就像学习走路一样</p><p>怎样培养独立和无条件的自尊</p><p>如何提高自己自尊水平</p>]]></content>
      
      
      <categories>
          
          <category> 心理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《门前》</title>
      <link href="/2020/05/18/%E3%80%8A%E9%97%A8%E5%89%8D%E3%80%8B/"/>
      <url>/2020/05/18/%E3%80%8A%E9%97%A8%E5%89%8D%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<pre><code>《门前》 顾城</code></pre><p>我多么希望，有一个门口<br>早晨，阳光照在草上</p><p>我们站着<br>扶着自己的门扇<br>门很低，但太阳是明亮的</p><p>草在结它的种子<br>风在摇它的叶子<br>我们站着，不说话<br>就十分美好</p><p>有门，不用开开<br>是我们的，就十分美好</p><p>早晨，黑夜还要流浪<br>我们把六弦琴交给他<br>我们不走了</p><p>我们需要土地<br>需要永不毁灭的土地<br>我们要乘着它<br>度过一生</p><p>土地是粗糙的，有时狭隘<br>然而，它有历史<br>有一份天空，一份月亮<br>一份露水和早晨</p><p>我们爱土地<br>我们站着<br>用木鞋挖着泥土<br>门也晒热了<br>我们轻轻靠着，十分美好</p><p>墙后的草<br>不会再长大了<br>它只用指尖，触了触阳光</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《When You Are Old》</title>
      <link href="/2020/05/16/%E3%80%8AWhen-You-Are-Old%E3%80%8B/"/>
      <url>/2020/05/16/%E3%80%8AWhen-You-Are-Old%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>When You Are Old<br>《当你老了》<br>——William Butler Yeats<br>冰心译</p><p>When you are old and grey and full of sleep,<br>当你老了，头发花白，睡意沉沉，<br>And nodding by the fire, take down this book,<br>倦坐在炉边，取下这本书来，<br>And slowly read, and dream of the soft look<br>慢慢读着，追梦当年的眼神<br>Your eyes had once, and of their shadows deep;<br>那柔美的神采与深幽的晕影。</p><a id="more"></a><p>How many loved your moments of glad grace,<br>多少人爱过你青春的片影，<br>And loved your beauty with love false or true,<br>爱过你的美貌，以虚伪或是真情，<br>But one man loved the pilgrim soul in you,<br>惟独一人爱你那朝圣者的心，<br>And loved the sorrows of your changing face;<br>爱你哀戚的脸上岁月的留痕。<br>And bending down beside the glowing bars,<br>在炉栅边，你弯下了腰，<br>Murmur, a little sadly, how love fled<br>低语着，带着浅浅的伤感，<br>And paced upon the mountains overhead<br>爱情是怎样逝去，又怎样步上群山，<br>And hid his face amid a crowd of stars.<br>怎样在繁星之间藏住了脸。</p><p>　　　　　　　　</p><p>　　　　　　　　　　　</p>]]></content>
      
      
      <categories>
          
          <category> poem </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程</title>
      <link href="/2020/05/15/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/05/15/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>使用 C++11 编写 Linux 多线程程序</p><p><a href="https://www.ibm.com/developerworks/cn/linux/1412_zhupx_thread/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/1412_zhupx_thread/index.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2020/05/12/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2020/05/12/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>火车站售票问题 四个窗口 卖票 线程不安全</p><p>synchronize和Lock的区别<br>Lock Java队列实现<br>synchronize 操作系统实现</p><p>数据库MySQl<br>Redis数据库<br>    1.缓存有效期<br>    2.SETNX命令<br>    3.lua脚本</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++虚函数与多态</title>
      <link href="/2020/05/02/C-%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
      <url>/2020/05/02/C-%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="C-纯虚函数与抽象类"><a href="#C-纯虚函数与抽象类" class="headerlink" title="C++ - 纯虚函数与抽象类"></a>C++ - 纯虚函数与抽象类</h2><p><a href="https://blog.csdn.net/qq_41453285/article/details/92715943" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/92715943</a></p><p><a href="https://www.jianshu.com/p/852e5bf33f4a" target="_blank" rel="noopener">https://www.jianshu.com/p/852e5bf33f4a</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime</title>
      <link href="/2020/05/02/sublime/"/>
      <url>/2020/05/02/sublime/</url>
      
        <content type="html"><![CDATA[<p>代码自动补全插件 TabNine<br>    command + shift + p 选择Install Packages<br>    再次command + shift + p 选择TabNine安装</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atom</title>
      <link href="/2020/04/29/Atom/"/>
      <url>/2020/04/29/Atom/</url>
      
        <content type="html"><![CDATA[<h2 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h2><pre><code>预览markdown shift+ctrl+m隐藏sidebar  command + k/b   view-&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nest.md</title>
      <link href="/2020/04/28/nest/"/>
      <url>/2020/04/28/nest/</url>
      
        <content type="html"><![CDATA[<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><pre><code>Conda(Linux/macOS    <figure class="highlight plain"><figcaption><span>create --name ENVNAME -c conda-forge nest-simulator</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate ENVNAME</span><br></pre></td></tr></table></figure>注意python的版本    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which python</span><br><span class="line">which nest</span><br></pre></td></tr></table></figure>if something is missing, try    `conda install &lt;package&gt;`</code></pre><h2 id="NEST-Documentation"><a href="#NEST-Documentation" class="headerlink" title="NEST Documentation"></a>NEST Documentation</h2><p>NEST is a simulator for spiking neural network models</p><ol><li>Models of information processing, in the visual or auditory cortex of mammals</li><li>Models of network activity dynamics, laminar cortical networks or balanced random networks</li><li>Models of learning and plasticity.</li></ol><h2 id="MUSIC-Interface"><a href="#MUSIC-Interface" class="headerlink" title="MUSIC Interface"></a>MUSIC Interface</h2><p>A standard by the INCF, allows the transmission of data between applications at runtime</p><p>MUSIC is an API allowing large scale neuron simulators using MPI<br>internally to exchange data during runtime. </p><p>MPI : 消息传递接口（英语：Message Passing Interface，缩写MPI）是一个并行计算的应用程序接口（API），常在超级电脑、电脑集群等非共享内存环境程序设计。</p><p>MUSIC provides mechanisms to transfer massive amounts of event information and continuous values<br>from one parallel application to another.</p><p>two most important components<br>    music library : ‘libmusic.a’<br>    music utility : ‘music’</p><ul><li>Getting started</li></ul><p>MUSIC proxies are devices, not regular neuron models</p>]]></content>
      
      
      
        <tags>
            
            <tag> nest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>design_patterns</title>
      <link href="/2020/04/27/design_patterns/"/>
      <url>/2020/04/27/design_patterns/</url>
      
        <content type="html"><![CDATA[<p>目标<br>    - 理解松耦合设计思想<br>    - 掌握面向对象设计原则<br>    - 掌握重构技法改善设计<br>    - 掌握GOF核心设计模式</p><p>《设计模式 可复用面向对象软件的基础》</p><h2 id="底层思维"><a href="#底层思维" class="headerlink" title="底层思维"></a>底层思维</h2><pre><code>向下，如何把握机器底层 从微观理解对象构造* 语言构造* 编译转换* 内存模型* 运行时机制深入理解面向对象向下：深入理解三大面向对象机制* 封装， 隐藏内部实现* 继承， 复用现有代码* 多态， 改写对象行为</code></pre><h2 id="抽象思维"><a href="#抽象思维" class="headerlink" title="抽象思维"></a>抽象思维</h2><pre><code>向上，如何将我们的周围世界抽象为程序代码* 面向对象* 组件封装* 设计模式* 架构模式</code></pre><a id="more"></a><h2 id="如何解决复杂性"><a href="#如何解决复杂性" class="headerlink" title="如何解决复杂性"></a>如何解决复杂性</h2><ul><li><p>分解</p><ul><li>分而治之</li></ul></li><li><p>抽象</p><ul><li>多态</li><li>只需修改很少的代码</li></ul></li></ul><p><strong>复用</strong></p><h2 id="八大面向对象设计原则"><a href="#八大面向对象设计原则" class="headerlink" title="八大面向对象设计原则"></a>八大面向对象设计原则</h2><pre><code>* 依赖倒置原则（DIP）    隔离变化* 开放封闭原则（OCP）    对扩展开放，对更改封闭* 单一职责原则（SRP）    一个类应该仅有一个引起它变化的原因    变化的方向隐含着类的责任* Liskov替换原则（LSP）    子类必须能够替换他们的基类（is a）* 接口隔离原则（ISP）    接口应该小而完备* 优先使用对象组合（黑箱复用），而不是类继承（白箱复用）    继承在某种程度上破坏了封装性，子类父类耦合度高    而对象组合只要求被组合的对象具有良好定义的接口* 封装变化点* 针对接口编程，而不是针对实现编程    高内聚、松耦合</code></pre><p><strong>接口标准化</strong></p><h2 id="GOF-23模式分类"><a href="#GOF-23模式分类" class="headerlink" title="GOF-23模式分类"></a>GOF-23模式分类</h2><pre><code>从目的来看    * 创建型 Creational    * 结构型 Structural    * 行为型 Behavioral从范围来看    * 类模式处理类与子类的静态关系    * 对象模式处理对象间的动态关系从封装变化角度对模式分类    组件协作        现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用之间的松耦合，是二者之间协作时常用的模式                    * Template Method 模版方法            稳定 变化        * Strategy 策略模式            扩展 而不是更改源码 遵循开闭原则 if-else            定义一系列算法，把他们一个个封装起来，并且使它们可互相变化（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）        * Observer/Event    单一职责        * Decorator        * Bridge    对象创建        * Factory Method        * Abstract Factory        * Prototype        * Builder    对象性能        * Singleton        * Flyweight    接口隔离        * Facade        * Proxy        * Mediator        * Adapter    状态变化        * Memento        * State    数据结构        * Composite        * Iterator        * Chain of Resposibility    行为变化        * Command        * Visitor    领域问题        * Interpreter</code></pre><p>应对变化 提高复用</p><h2 id="重构书籍推荐"><a href="#重构书籍推荐" class="headerlink" title="重构书籍推荐"></a>重构书籍推荐</h2><p>《重构–改善既有代码的设计》<br>《重构与模式》</p><p>重构关键技法<br>    静态 -&gt;动态<br>    早绑定 -&gt; 晚绑定<br>    继承 -&gt; 组合<br>    编译时依赖 -&gt; 运行时依赖<br>    紧耦合 -&gt; 松耦合</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/2020/04/25/markdown/"/>
      <url>/2020/04/25/markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="markdown-预览"><a href="#markdown-预览" class="headerlink" title="markdown 预览"></a>markdown 预览</h2><p><a href="https://blog.csdn.net/qq_20011607/article/details/81370236" target="_blank" rel="noopener">https://blog.csdn.net/qq_20011607/article/details/81370236</a></p><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">#### 这是五级标题</span><br><span class="line">##### 这是六级标题</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h4 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h4><h5 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h5><hr><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**加粗**</span><br><span class="line">***斜体加粗***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><p><em>斜体</em><br><strong>加粗</strong><br><strong><em>斜体加粗</em></strong><br><del>这是加删除线的文字</del></p><hr><h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h2><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p></blockquote></blockquote><h2 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br></pre></td></tr></table></figure><hr><hr><hr><h2 id="5-图片"><a href="#5-图片" class="headerlink" title="5.图片"></a>5.图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><p>![blockchain](<a href="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/" target="_blank" rel="noopener">https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</a><br>u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”)</p><hr><h2 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6.超链接"></a>6.超链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure><h2 id="Vincent的银河系漫游指南"><a href="#Vincent的银河系漫游指南" class="headerlink" title="Vincent的银河系漫游指南"></a><a href="https://vincentcheungkokomo.github.io/">Vincent的银河系漫游指南</a></h2><h2 id="7-列表"><a href="#7-列表" class="headerlink" title="7.列表"></a>7.列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>语法： 无序列表用-+*任何一种都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容1</span><br><span class="line">+ 列表内容2</span><br><span class="line">* 列表内容3</span><br></pre></td></tr></table></figure><ul><li>列表内容1</li></ul><ul><li>列表内容2</li></ul><ul><li>列表内容3</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br></pre></td></tr></table></figure><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 一级无序列表内容</span><br><span class="line">    * 二级无序列表内容1</span><br><span class="line">    * 二级无序列表内容2</span><br></pre></td></tr></table></figure><ul><li>一级无序列表内容<ul><li>二级无序列表内容1</li><li>二级无序列表内容2</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 一级无序列表内容</span><br><span class="line">    1. 二级有序列表内容1</span><br><span class="line">    2. 二级有序列表内容2</span><br></pre></td></tr></table></figure><ul><li>一级无序列表内容<ol><li>二级有序列表内容1</li><li>二级有序列表内容2</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 一级有序列表内容1</span><br><span class="line">    * 二级无序列表内容1</span><br><span class="line">    * 二级无序列表内容2</span><br></pre></td></tr></table></figure><ol><li>一级有序列表内容1<ul><li>二级无序列表内容1</li><li>二级无序列表内容2</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. 一级有序列表内容2</span><br><span class="line">    1. 二级有序列表内容1</span><br><span class="line">    2. 二级有序列表内容2</span><br></pre></td></tr></table></figure><ol start="2"><li>一级有序列表内容2<ol><li>二级有序列表内容1</li><li>二级有序列表内容2</li></ol></li></ol><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><h2 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h2><p>语法:<br>单行代码：代码之间分别用一个反引号包起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;代码内容&#96;</span><br></pre></td></tr></table></figure><p><code>create database hero;</code></p><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行代码</span><br><span class="line">第二行代码</span><br><span class="line">第三行代码</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">    echo &quot;Don&#39;t forget to be awesome!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure><hr><h2 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flow</span><br><span class="line">st&#x3D;&gt;start: Start</span><br><span class="line">op&#x3D;&gt;operation: Your Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;hello world&#39;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/04/25/test/"/>
      <url>/2020/04/25/test/</url>
      
        <content type="html"><![CDATA[<h2 id="解决点击标签分类显示-Cannot-GET-tags-20"><a href="#解决点击标签分类显示-Cannot-GET-tags-20" class="headerlink" title="解决点击标签分类显示 Cannot GET /tags/%20/"></a>解决点击标签分类显示 Cannot GET /tags/%20/</h2><p>参考 <a href="https://www.jianshu.com/p/b671e4082c13" target="_blank" rel="noopener">https://www.jianshu.com/p/b671e4082c13</a></p><h2 id="Hexo使用NexT主题设置主页显示文章摘要方法"><a href="#Hexo使用NexT主题设置主页显示文章摘要方法" class="headerlink" title="Hexo使用NexT主题设置主页显示文章摘要方法"></a>Hexo使用NexT主题设置主页显示文章摘要方法</h2><pre><code>1. 在文章中使用&lt;!--more--&gt;进行手动截断</code></pre><h2 id="利用-Hexo-Github-Pages-搭建博客并优化-Next-主题教程"><a href="#利用-Hexo-Github-Pages-搭建博客并优化-Next-主题教程" class="headerlink" title="利用 Hexo + Github Pages 搭建博客并优化 Next 主题教程"></a>利用 Hexo + Github Pages 搭建博客并优化 Next 主题教程</h2><pre><code>https://michael728.github.io/2019/05/19/hexo-blog-full-note/</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Nest搭建个人博客</title>
      <link href="/2020/04/23/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2020/04/23/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h2><p>Node.js是能够在服务器端运行JavaScript 的开放源代码、跨平台 JavaScript 运行环境。</p><p>查看node版本 <code>node -v</code></p><p>查看npm包管理器版本 <code>npm -v</code></p><h2 id="2-npm安装Hexo"><a href="#2-npm安装Hexo" class="headerlink" title="2. npm安装Hexo"></a>2. npm安装Hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="3-使用Hexo搭建博客"><a href="#3-使用Hexo搭建博客" class="headerlink" title="3. 使用Hexo搭建博客"></a>3. 使用Hexo搭建博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir blog</span><br><span class="line">$ <span class="built_in">cd</span> blog/</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="4-启动博客"><a href="#4-启动博客" class="headerlink" title="4.启动博客"></a>4.启动博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s // 启动本地服务 localhost:4000 hexo默认创建了主题为hello world的文章</span><br><span class="line">$ hexo n <span class="string">"我的第一篇博客文章"</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">source</span>/_posts/</span><br><span class="line">$ subl 我的第一篇博客文章.md  // 用sublime进行编辑</span><br><span class="line">$ <span class="built_in">cd</span> ../.. // 切换到myblog目录</span><br><span class="line">$ hexo clean // 清理</span><br><span class="line">$ hexo g // 生成</span><br><span class="line">$ hexo s // 启动</span><br></pre></td></tr></table></figure><h2 id="5-部署到xxx-gitHub-io"><a href="#5-部署到xxx-gitHub-io" class="headerlink" title="5. 部署到xxx.gitHub.io"></a>5. 部署到xxx.gitHub.io</h2><p>github 新建仓库</p><pre><code>Create new repository</code></pre><p>仓库名与GitHub帐号名相同</p><pre><code>repository name : username.github.io // 浏览器输入该地址可访问</code></pre><p>在blog目录下安装git部署的插件</p><p>安装<br>    hexo-deployer-git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>修改站点配置文件 /blog/_config.yml </p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/username/username.github.io.git  branch: master</code></pre><p>部署到远端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.email <span class="string">"you@example.com"</span></span><br><span class="line">$ git config --global git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>更改站点配置文件 /blog/_config.yml<br>    theme: next</p><p>重新生成部署</p><pre><code>hexo cleanhexo ghexo shexo d</code></pre><p>添加评论系统<br>    <a href="https://bluelzy.com/articles/use_valine_for_your_blog.html" target="_blank" rel="noopener">https://bluelzy.com/articles/use_valine_for_your_blog.html</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=15921694224540162753" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=15921694224540162753</a>    </p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/23/hello-world/"/>
      <url>/2020/04/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
